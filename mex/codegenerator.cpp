/*
   Copyright (C) 2022 Pascal Heiter
   ----------------------------------------------------------------------------
  This file is part of AMMSoCK.

  AMMSoCK is free software: you can redistribute it and/or modify it under the
  terms of the GNU General Public License as published by the Free Software
  Foundation, either version 3 of the License, or (at your option) any later
  version. AMMSoCK is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
  details. You should have received a copy of the GNU General Public License
  along with AMMSoCK. If not, see <https://www.gnu.org/licenses/>.
*/

#include <algorithm>
#include <assert.h>
#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <time.h>
#include <vector>

// get AMMSoCK stats: nstages, Acoll and nrpv
#include "./cpp/generationStats.hpp"

using namespace std;

int thirdBodyOccurs(vector<int> bodyPos, int index) {
  for (int i = 0; i < bodyPos.size(); ++i) {
    if (bodyPos[i] == (index + 1)) {
      return i;
    }
  }
  return -1;
}

int getIndexOfToken(string token, vector<string> species) {
  for (int i = 0; i < species.size(); i++) {
    if (species[i].compare(token) == 0) {
      return i;
    };
  }
  return -1;
}

void generateBoundsInfo(int nspec, vector<string> species, int natom,
                        string filename) {

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream out("get_bounds_info.hpp");
  out << "/* Autogenerated file on " << ctime(&t);
  out << " *    Function defining the boundaries, i.e. the upper and lower "
         "bounds of the optimization problem"
      << endl;
  out << " *    Mechanism: " << filename << endl;
  out << " */" << endl;
  out << "bool ammsockNLP::get_bounds_info(Index n, Number* x_l, Number* x_u, "
         "Index m, Number* g_l, Number* g_u) {"
      << endl
      << endl;

  // prepare preliminares
  out << "   // Assertions" << endl;
  out << "   assert(n == " << ((NINT + 1) * NSTAGES + 1) * (NOP + 1) << ");"
      << endl;
  if (NNOP > 0) {
    out << "   assert(m == "
        << NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 +
               NNOP * ((NINT + 1) * NSTAGES + 1)
        << ");" << endl;
  } else {
    out << "   assert(m == "
        << NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 + NATOM << ");" << endl;
  }
  out << endl;

  // upper and lower bound for optimization variables
  out << "   //set lower and upper bounds for op variables" << endl;
  out << "   for (int i = 0; i < n; ++i) {" << endl;
  out << "      x_l[i] = 0.0;" << endl;
  out << "      //set upper bound for the temperatures to 4000 Kelvin" << endl;
  out << "      if ((i+1)%" << NOP + 1 << " == 0) {" << endl;
  out << "         x_u[i] = 4000.0;" << endl;
  out << "      } else {" << endl;
  out << "         x_u[i] = 1.0;" << endl;
  out << "      }" << endl;
  out << "   }" << endl << endl;

  // upper and lower bound for constraints
  int upper = -1;
  if (NNOP > 0) {
    upper = NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1;
  } else {
    upper = NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 + NATOM;
  }
  out << "   //set lower and upper bounds for constraints" << endl;
  out << "   for (int i = 0; i < " << upper << "; ++i) {" << endl;
  out << "      g_l[i] = 0.0;" << endl;
  out << "      g_u[i] = 0.0;" << endl;
  out << "   }" << endl << endl;
  out << "   //set low and upper bounds for nontrivial inequailities "
         "(resolution)"
      << endl;
  out << "   for (int i = " << upper << "; i < m; ++i) {" << endl;
  out << "      g_l[i] = 0.0;" << endl;
  out << "      g_u[i] = 1.0;" << endl;
  out << "   }" << endl << endl;

  out << "   return true;" << endl;
  out << endl;
  out << "}" << endl;
  out.close();
}

void generateNLPInfo(int nspec, vector<string> species, int natom,
                     string filename) {

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream out("get_nlp_info.hpp");
  out << "/* Autogenerated file on " << ctime(&t);
  out << " *    Function defining the essential informations of the "
         "optimization problem"
      << endl;
  out << " *    Mechanism: " << filename << endl;
  out << " */" << endl;
  out << "bool ammsockNLP::get_nlp_info(Index& n, Index& m, Index& nnz_jac_g, "
         "Index& nnz_h_lag, IndexStyleEnum& index_style){"
      << endl
      << endl;

  // set problem dimension
  out << "   //set problem dimension" << endl;
  out << "   n = " << ((NINT + 1) * NSTAGES + 1) * (NOP + 1) << ";" << endl;
  if (NNOP > 0) {
    out << "   m = "
        << NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 +
               NNOP * ((NINT + 1) * NSTAGES + 1)
        << ";" << endl;
  } else {
    out << "   m = " << NRPV + (NINT + 1) * NSTAGES * (NOP + 1) + 1 + NATOM
        << ";" << endl;
  }
  out << endl;

  // set nonzeros in jacobian and hessian
  out << "   //set nonzeros in jacobian and hessian" << endl;
  if (NNOP > 0) {
    out << "   nnz_jac_g = "
        << NSTAGES * NOP + (NOP + 1) + NINT * NSTAGES * NOP +
               (NINT + 1) *
                   (NSTAGES * NSTAGES * NOP * (NOP + 1) + (NOP + 1) * NSTAGES) +
               NRPV + (NSTAGES * (NINT + 1) + 1) * NOP * NNOP
        << ";" << endl;
  } else {
    out << "   nnz_jac_g = "
        << NSTAGES * NOP + (NOP + 1) + NINT * NSTAGES * NOP +
               (NINT + 1) *
                   (NSTAGES * NSTAGES * NOP * (NOP + 1) + (NOP + 1) * NSTAGES) +
               NRPV + NATOM * NOP
        << ";" << endl;
  }
  out << "   nnz_h_lag = "
      << (NOP + 1) * (NOP + 1) + (NINT + 1) * NSTAGES * (NOP + 1) * (NOP + 1)
      << ";" << endl;
  out << endl;

  // set index style
  out << "   //set index style" << endl;
  out << "   index_style = FORTRAN_STYLE;" << endl;
  out << endl;

  out << "   return true;" << endl;
  out << endl;
  out << "}" << endl;
  out.close();
}

void generateRHS(int nspec, int nreac, int natom, vector<string> species,
                 vector<vector<int>> nuprime, vector<vector<int>> nu2prime,
                 vector<int> bodyPos, vector<int> bodyNumber,
                 vector<vector<double>> bodyCoeff, vector<double> Ms,
                 vector<vector<double>> nasa, vector<double> switchingPoints,
                 string filename) {

  int nop = NOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;

  // generate nu
  vector<vector<int>> nu(nspec, vector<int>(nreac, 0));
  for (int i = 0; i < nu.size(); ++i) {
    for (int k = 0; k < nu[0].size(); ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  // ofstream rhs(("rhs_"+filename+".m").c_str());
  ofstream rhs("odefun.m");
  rhs << "% Autogenerated file on " << ctime(&t);
  rhs << "% odefun.m" << endl;
  rhs << "%    Description: Calculates the change of mass fractions of each "
         "species"
      << endl;
  rhs << "%    Input: t - time." << endl;
  rhs << "%           X = (Y,T) - with mass fractions Y of each species and"
      << endl;
  rhs << "%                        temperature T." << endl;
  rhs << "%           param - struct containing resolution if present." << endl;
  rhs << "%    Output: f - change of mass fractions of each species." << endl;
  rhs << "function f = odefun(t,X,param)" << endl << endl;

  rhs << "% Preliminaries" << endl;
  rhs << "Y = zeros(" << nspec << ",1);" << endl;
  rhs << "% set Iop variables" << endl;
  for (int i = 0; i < NOP; ++i) {
    rhs << "Y(" << Iop[i] << ") = X(" << i + 1 << ");" << endl;
  }
  rhs << "% set Inop variables" << endl;
  for (int i = 0; i < NNOP; ++i) {
    rhs << "Y(" << Inop[i] << ") = param.Y{" << i + 1 << "}(X(1:end-1));"
        << endl;
  }
  rhs << "T = X(end);" << endl;
  rhs << "[kf,kr] = rates(T);" << endl;
  rhs << "gamma = 20;" << endl;

  // generating nasa
  rhs << "nasa = [";
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < 14; ++k) {
      rhs << std::setprecision(15) << nasa[i][k] << " ";
    }
    rhs << ";" << endl;
  }
  rhs << "]; % coefficients for nasa polynomials - each line: "
         "[a1_low,...,a7_low,a1_high,..,a7_high]"
      << endl;

  // generating switching points
  rhs << "T_sw = [";
  for (int k = 0; k < nspec; ++k) {
    rhs << switchingPoints[k] << " ";
  }
  rhs << "]; \% switching points between branches" << endl;
  rhs << "q = zeros(" << nreac << ",1);" << endl;
  rhs << "M = zeros(" << bodyCoeff.size() << ",1);" << endl;
  rhs << "omega = zeros(" << nspec << ",1);" << endl;
  rhs << "f = zeros(" << nop << ",1);" << endl;
  rhs << "C_low = zeros(" << nspec << ",1);" << endl;
  rhs << "C_high = zeros(" << nspec << ",1);" << endl;
  rhs << "H_low = zeros(" << nspec << ",1);" << endl;
  rhs << "H_high = zeros(" << nspec << ",1);" << endl;
  rhs << "Cbar = zeros(" << nspec << ",1);" << endl;
  rhs << "Hbar = zeros(" << nspec << ",1);" << endl;
  rhs << "Ms = [";
  for (int i = 0; i < Ms.size(); ++i) {
    rhs << std::setprecision(15) << 1e-3 * Ms[i] << " ";
  }
  rhs << "]; \% molar weights in kg/mol" << endl;
  rhs << "p = 101325; \% fixed pressure (1 atm) in isobaric case" << endl;
  rhs << "R = 8.3144598;" << endl;
  rhs << "Mbar = 1/sum(Y(:)./Ms(:));" << endl;
  rhs << "rho = p*Mbar/(R*T);" << endl << endl;

  // generating Hbar_{low,high}
  rhs << endl << "%% calculate H_{low,high}" << endl;
  rhs << "for i=1:" << nspec << endl;
  rhs << "   C_low(i)  = R*(nasa(i,1) + nasa(i,2)*T + nasa(i,3)*T^2 + "
         "nasa(i,4)*T^3 + nasa(i,5)*T^4);"
      << endl;
  rhs << "   C_high(i) = R*(nasa(i,8) + nasa(i,9)*T + nasa(i,10)*T^2 + "
         "nasa(i,11)*T^3 + nasa(i,12)*T^4);"
      << endl;
  rhs << "   H_low(i)  = R*(nasa(i,1)*T + nasa(i,2)/2*T^2 + nasa(i,3)/3*T^3 + "
         "nasa(i,4)/4*T^4 + nasa(i,5)/5*T^5 + nasa(i,6));"
      << endl;
  rhs << "   H_high(i) = R*(nasa(i,8)*T + nasa(i,9)/2*T^2 + nasa(i,10)/3*T^3 + "
         "nasa(i,11)/4*T^4 + nasa(i,12)/5*T^5 + nasa(i,13));"
      << endl;
  rhs << "end" << endl << endl;

  // generating Hbar
  rhs << "%% calculate Hbar" << endl;
  rhs << "for i=1:" << nspec << endl;
  rhs << "   sigma = 1/2*tanh(gamma*(T-T_sw(i))) + 1/2;" << endl;
  rhs << "   Hbar(i) = (1-sigma)*H_low(i) + sigma*H_high(i);" << endl;
  rhs << "   Cbar(i) = (1-sigma)*C_low(i) + sigma*C_high(i);" << endl;
  rhs << "end" << endl << endl;

  // generating third bodies
  rhs << "% Generate third bodies" << endl;
  for (int i = 0; i < bodyCoeff.size(); ++i) {
    rhs << "M(" << i + 1 << ") = 0.0";
    for (int k = 0; k < nspec; ++k) {
      rhs << " + " << bodyCoeff[i][k] << " * rho*Y(" << k + 1 << ")/Ms("
          << k + 1 << ")";
    }
    rhs << ";" << endl;
  }
  rhs << endl;

  // generating q_r
  rhs << "% Generate each reaction q_r" << endl;
  for (int i = 0; i < nreac; ++i) {
    rhs << "q(" << i + 1 << ") = "
        << "kf(" << i + 1 << ") ";
    for (int s = 0; s < nspec; ++s) {
      int exponent = nuprime[s][i];
      if (exponent != 0) {
        for (int k = 1; k <= exponent; ++k) {
          rhs << "* rho * Y(" << s + 1 << ")/Ms(" << s + 1 << ") ";
        }
      }
    }
    rhs << " - kr(" << i + 1 << ") ";
    for (int s = 0; s < nspec; ++s) {
      int exponent = nu2prime[s][i];
      if (exponent != 0) {
        for (int k = 1; k <= exponent; ++k) {
          rhs << "* rho * Y(" << s + 1 << ")/Ms(" << s + 1 << ") ";
        }
      }
    }
    rhs << ";" << endl;
  }
  rhs << endl;

  // link q_r and third bodies
  rhs << "% Insert third bodies into reactions" << endl;
  for (int i = 0; i < bodyNumber.size(); ++i) {
    rhs << "q(" << bodyPos[i] << ") = M(" << bodyNumber[i] << ") * q("
        << bodyPos[i] << ");" << endl;
  }
  rhs << endl;

  // generating omega
  rhs << "% Generate omega" << endl;
  for (int s = 0; s < nspec; ++s) {
    rhs << "omega(" << s + 1 << ") = 0 ";
    for (int r = 0; r < nreac; ++r) {
      if (nu[s][r] != 0)
        rhs << "+ (" << nu[s][r] << ") * "
            << "q(" << r + 1 << ") ";
    }
    rhs << ";" << endl;
  }
  rhs << endl;

  // generating dotY
  rhs << "% Generate dotY" << endl;
  for (int s = 0; s < nop; ++s) {
    rhs << "f(" << s + 1 << ") = Ms(" << Iop[s] << ")/rho * omega(" << Iop[s]
        << ");" << endl;
  }

  rhs << "f(" << nop + 1
      << ") = - (R*T*sum(Hbar(:).*omega(:)) * sum(Y(:)./Ms(:))) / (p * "
         "sum(Cbar(:).*Y(:)./Ms(:)));"
      << endl;
  rhs.close();
}

void generateEvalF(int nspec, int nreac, vector<string> species,
                   vector<vector<int>> nuprime, vector<vector<int>> nu2prime,
                   vector<int> bodyPos, vector<int> bodyNumber,
                   vector<vector<double>> bodyCoeff, vector<double> Ms,
                   string filename) {

  int nop = NOP;

  // generate nu
  vector<vector<int>> nu(nspec, vector<int>(nreac, 0));
  for (int i = 0; i < nu.size(); ++i) {
    for (int k = 0; k < nu[0].size(); ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalf("eval_f.hpp");
  evalf << "/* Autogenerated file on " << ctime(&t);
  evalf << " *    Function defining the objective functional" << endl;
  evalf << " *    Mechanism: " << filename << endl;
  evalf << " */" << endl;
  //		evalf << endl << "#include <rates.hpp>" << endl << endl;
  evalf << "bool ammsockNLP::eval_f(Index n, const Number* x, bool new_x, "
           "Number& objvalue) {"
        << endl
        << endl;

  // rename variables
  evalf << "   // Preliminaries - get (Y00,T00)" << endl;
  evalf << "   Number Y[" << nop << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalf << "   Y[" << i << "] = x[" << i << "];" << endl;
  }
  evalf << "   Number T = x[" << nop << "];" << endl << endl;

  // get first derivative
  evalf << "   // get f and first derivative dYf" << endl;
  evalf << "   Number f[" << nop << "], dTf[" << nop << "], dYf[" << nop << "]["
        << nop << "], H[" << nspec << "], dTH[" << nspec << "];" << endl;
  evalf << "   getFirstDerivative_f(T, Y, f, dYf, dTf, H, dTH);" << endl
        << endl;

  // generate objval
  evalf << "   // Generate objvalue" << endl;
  evalf << "   objvalue = 0.0;" << endl;
  for (int i = 0; i < nop; ++i) {
    evalf << "   objvalue += pow( 0.0 ";
    for (int j = 0; j < nop; ++j) {
      evalf << " + dYf[" << i << "][" << j << "]*f[" << j << "]";
    }
    evalf << ",2);" << endl;
  }

  // scale objvalue
  evalf << endl << "   // scale objvalue" << endl;
  evalf << "   objvalue *= scale;" << endl;

  evalf << endl << "   return true;" << endl;
  evalf << "}" << endl;
  evalf.close();
}

void generateEvalGradF(int nspec, int nreac, vector<string> species,
                       vector<vector<int>> nuprime,
                       vector<vector<int>> nu2prime, vector<int> bodyPos,
                       vector<int> bodyNumber, vector<vector<double>> bodyCoeff,
                       vector<double> Ms, string filename) {

  int nop = NOP;

  // generate nu
  vector<vector<int>> nu(nspec, vector<int>(nreac, 0));
  for (int i = 0; i < nu.size(); ++i) {
    for (int k = 0; k < nu[0].size(); ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalf("eval_grad_f.hpp");
  evalf << "/* Autogenerated file on " << ctime(&t);
  evalf << " *    Function defining the gradient of the objective functional"
        << endl;
  evalf << " *    Mechanism: " << filename << endl;
  evalf << " */" << endl;
  evalf << "bool ammsockNLP::eval_grad_f(Index n, const Number* x, bool new_x, "
           "Number* grad_f) {"
        << endl
        << endl;

  // rename variables
  evalf << "   //get variables (Y_0_0,T_0_0)" << endl;
  evalf << "   Number Y[" << nop << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalf << "   Y[" << i << "] = x[" << i << "];" << endl;
  }
  evalf << "   Number T = x[" << nop << "];" << endl;
  evalf << endl;

  // prepare preliminares
  evalf << "   // Preliminaries" << endl;
  evalf << "   Number f[" << nop << "], dYf[" << nop << "][" << nop << "], dTf["
        << nop << "], dYYf[" << nop << "][" << nop << "][" << nop << "], dYTf["
        << nop << "][" << nop << "];" << endl;
  evalf << "   Number H[" << nspec << "], dTH[" << nspec << "], dTTH[" << nspec
        << "];" << endl;
  evalf << endl;

  evalf << "   //get required derivatives" << endl;
  evalf << "   getSecondDerivative_f(T,Y,f,dYf,dTf,dYYf,dYTf,H,dTH,dTTH);"
        << endl;
  evalf << endl;

  // generate gradF
  evalf << "   // Generate gradient grad_F" << endl;
  for (int m = 0; m < nop; ++m) {
    evalf << "   grad_f[" << m << "] = 0.0;" << endl;
    for (int i = 0; i < nop; ++i) {
      evalf << "   grad_f[" << m << "] += 2.0 * ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalf << " + dYf[" << i << "][" << s << "] * f[" << s << "]";
      }
      evalf << ") * ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalf << " + dYYf[" << i << "][" << s << "][" << m << "] * f[" << s
              << "] + dYf[" << i << "][" << s << "] * dYf[" << s << "][" << m
              << "]";
      }
      evalf << ");" << endl;
    }
    evalf << endl;
  }

  // generate gradF
  evalf << "   // Generate gradient grad_F resp. T" << endl;
  evalf << "   grad_f[" << nop << "] = 0.0;" << endl;
  for (int i = 0; i < nop; ++i) {
    evalf << "   grad_f[" << nop << "] += 2.0 * ( 0.0";
    for (int s = 0; s < nop; ++s) {
      evalf << " + dYf[" << i << "][" << s << "] * f[" << s << "]";
    }
    evalf << ") * ( 0.0";
    for (int s = 0; s < nop; ++s) {
      evalf << " + dYTf[" << i << "][" << s << "] * f[" << s << "] + dYf[" << i
            << "][" << s << "] * dTf[" << s << "]";
    }
    evalf << ");" << endl;
  }
  evalf << endl;

  // scale gradient
  evalf << "   // scale gradient" << endl;
  for (int i = 0; i < nop + 1; ++i) {
    evalf << "   grad_f[" << i << "] *= scale;" << endl;
  }
  evalf << endl;

  // set rest to zero
  evalf << "   //set rest to zero" << endl;
  evalf << "   for (int i = " << nop + 1 << "; i < n; ++i) {" << endl;
  evalf << "      grad_f[i] = 0.0;" << endl;
  evalf << "   }" << endl;

  evalf << endl << endl << "   return true;" << endl;
  evalf << "}" << endl;
  evalf.close();
}

void generateEvalH(int nspec, int nreac, vector<string> species,
                   vector<vector<int>> nuprime, vector<vector<int>> nu2prime,
                   vector<int> bodyPos, vector<int> bodyNumber,
                   vector<vector<double>> bodyCoeff, vector<double> Ms,
                   string filename) {

  // set collocation schema
  double A[NSTAGES][NSTAGES] = ACOLL;

  // get problem dimensions
  int nop = NOP;
  int nnop = NNOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;

  // generate nu
  int nu[nspec][nreac];
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < nreac; ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalh("eval_h.hpp");
  evalh << "/* Autogenerated file on " << ctime(&t);
  evalh << " *    Function defining the exact Hessian of the lagrangian funtion"
        << endl;
  evalh << " *    Mechanism: " << filename << endl;
  evalh << " */" << endl;
  evalh << "bool ammsockNLP::eval_h(Index n, const Number* x, bool new_x, "
           "Number obj_factor, Index m, const Number* lambda, bool new_lambda, "
           "Index nele_hess, Index* iRow, Index *jCol, Number* values) {"
        << endl
        << endl;

  if (EXACTHESSIAN) {
    // check structure
    int n = ((NINT + 1) * NSTAGES + 1) * (NOP + 1);
    int nnzHess = 0;
    evalh << "   if (values == NULL) {" << endl;
    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= (NOP + 1); ++j) {
        evalh << "      iRow[" << nnzHess << "] = " << i << "; jCol[" << nnzHess
              << "] = " << ((int)(i - 1) / (NOP + 1)) * (NOP + 1) + j << ";"
              << endl;
        nnzHess++;
      }
    }
    evalh << "   } else {" << endl;

    // rename variables
    evalh << endl
          << "   //set variables and molar weights - coding NAME_INTERVAL_STAGE"
          << endl;
    evalh << std::setprecision(20);
    evalh << "   Number Ms[" << nspec << "] = { " << 1e-3 * Ms[0];
    for (int i = 1; i < Ms.size(); ++i) {
      evalh << ", " << 1e-3 * Ms[i];
    }
    evalh << "}; //molar weights in kg/mol" << endl;
    evalh << "   Number Y_0_0[" << nop << "] = { x[0]";
    for (int i = 1; i < nop; ++i) {
      evalh << ",  x[" << i << "]";
    }
    evalh << "}, T_0_0 = x[" << nop << "];" << endl;

    for (int k = 0; k <= NINT; ++k) {
      for (int s = 1; s <= NSTAGES; ++s) {
        evalh << "   Number Y_" << k << "_" << s << "[" << nop << "] = { x["
              << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + 1 << "]";
        for (int i = 1; i < nop; ++i) {
          evalh << ", x["
                << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + i + 1
                << "]";
        }
        evalh << "}, T_" << k << "_" << s << " = x["
              << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + nop + 1
              << "];" << endl;
      }
    }
    evalh << endl;

    // allocate memory for required derivatives
    evalh << "   // allocate memory for required derivatives" << endl;
    evalh << "   Number f_0_0[" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", f_" << k << "_" << i << "[" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number H_0_0[" << nspec << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", H_" << k << "_" << i << "[" << nspec << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number Yres_0_0[" << nnop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", Yres_" << k << "_" << i << "[" << nnop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dTf_0_0[" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dTf_" << k << "_" << i << "[" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dTH_0_0[" << nspec << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dTH_" << k << "_" << i << "[" << nspec << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dYf_0_0[" << nop << "][" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dYf_" << k << "_" << i << "[" << nop << "][" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dYYres_0_0[" << nnop << "][" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dYYres_" << k << "_" << i << "[" << nnop << "][" << nop
              << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dYYf_0_0[" << nop << "][" << nop << "][" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dYYf_" << k << "_" << i << "[" << nop << "][" << nop << "]["
              << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dYTf_0_0[" << nop << "][" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dYTf_" << k << "_" << i << "[" << nop << "][" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dTTf_0_0[" << nop << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dTTf_" << k << "_" << i << "[" << nop << "]";
      }
    }
    evalh << ";" << endl;
    evalh << "   Number dTTH_0_0[" << nspec << "]";
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << ", dTTH_" << k << "_" << i << "[" << nspec << "]";
      }
    }
    evalh << ";" << endl;

    evalh << "   Number dYYYf_0_0[" << nop << "][" << nop << "][" << nop << "]["
          << nop << "], dYYTf_0_0[" << nop << "][" << nop << "][" << nop
          << "], dYTTf_0_0[" << nop << "][" << nop << "];" << endl
          << endl;

    evalh << "   //get derivatives" << endl;
    evalh << "   getThirdDerivative_f(T_0_0, Y_0_0, f_0_0, dYf_0_0, dTf_0_0, "
             "dYYf_0_0, dYTf_0_0, dTTf_0_0, dYYYf_0_0, dYYTf_0_0, dYTTf_0_0, "
             "H_0_0, dTH_0_0, dTTH_0_0, Yres_0_0, dYYres_0_0);"
          << endl;
    for (int k = 0; k <= NINT; ++k) {
      for (int i = 1; i <= NSTAGES; ++i) {
        evalh << "   getSecondDerivative_f(T_" << k << "_" << i << ", Y_" << k
              << "_" << i << ", f_" << k << "_" << i << ", dYf_" << k << "_"
              << i << ", dTf_" << k << "_" << i << ", dYYf_" << k << "_" << i
              << ", dYTf_" << k << "_" << i << ", dTTf_" << k << "_" << i
              << ", H_" << k << "_" << i << ", dTH_" << k << "_" << i
              << ", dTTH_" << k << "_" << i << ", Yres_" << k << "_" << i
              << ", dYYres_" << k << "_" << i << ");" << endl;
      }
    }
    evalh << endl;

    evalh << "   //build HessF" << endl;
    evalh << "   Number HessF[" << NOP + 1 << "][" << NOP + 1 << "];" << endl;
    for (int m = 0; m < NOP; ++m) {
      for (int k = 0; k < NOP; ++k) {
        evalh << "   HessF[" << m << "][" << k << "] = 0.0;" << endl;
        for (int i = 0; i < nop; ++i) {
          evalh << "   HessF[" << m << "][" << k << "] += 2.0 * ( ( 0.0";
          for (int s = 0; s < nop; ++s) {
            evalh << " + dYYf_0_0[" << i << "][" << s << "][" << k
                  << "] * f_0_0[" << s << "] + dYf_0_0[" << i << "][" << s
                  << "] * dYf_0_0[" << s << "][" << k << "]";
          }
          evalh << ") * ( 0.0";
          for (int s = 0; s < nop; ++s) {
            evalh << " + dYYf_0_0[" << i << "][" << s << "][" << m
                  << "] * f_0_0[" << s << "] + dYf_0_0[" << i << "][" << s
                  << "] * dYf_0_0[" << s << "][" << m << "]";
          }
          evalh << ") + (0.0";
          for (int s = 0; s < nop; ++s) {
            evalh << " + dYf_0_0[" << i << "][" << s << "] * f_0_0[" << s
                  << "]";
          }
          evalh << ") * ( 0.0";
          for (int s = 0; s < nop; ++s) {
            evalh << " + dYYYf_0_0[" << i << "][" << s << "][" << m << "][" << k
                  << "] * f_0_0[" << s << "] + dYYf_0_0[" << i << "][" << s
                  << "][" << m << "] * dYf_0_0[" << s << "][" << k
                  << "] + dYYf_0_0[" << i << "][" << s << "][" << k
                  << "] * dYf_0_0[" << s << "][" << m << "] + dYYf_0_0[" << s
                  << "][" << m << "][" << k << "] * dYf_0_0[" << i << "][" << s
                  << "]";
          }
          evalh << "));" << endl;
        }
        evalh << endl;
      }
    }

    for (int m = 0; m < NOP; ++m) {
      evalh << "   HessF[" << NOP << "][" << m << "] = 0.0;" << endl;
      for (int i = 0; i < nop; ++i) {
        evalh << "   HessF[" << NOP << "][" << m << "] += 2.0 * ( ( 0.0";
        for (int s = 0; s < nop; ++s) {
          evalh << " + dYTf_0_0[" << i << "][" << s << "] * f_0_0[" << s
                << "] + dYf_0_0[" << i << "][" << s << "] * dTf_0_0[" << s
                << "]";
        }
        evalh << ") * ( 0.0";
        for (int s = 0; s < nop; ++s) {
          evalh << " + dYYf_0_0[" << i << "][" << s << "][" << m << "] * f_0_0["
                << s << "] + dYf_0_0[" << i << "][" << s << "] * dYf_0_0[" << s
                << "][" << m << "]";
        }
        evalh << ") + (0.0";
        for (int s = 0; s < nop; ++s) {
          evalh << " + dYf_0_0[" << i << "][" << s << "] * f_0_0[" << s << "]";
        }
        evalh << ") * ( 0.0";
        for (int s = 0; s < nop; ++s) {
          evalh << " + dYYTf_0_0[" << i << "][" << s << "][" << m
                << "] * f_0_0[" << s << "] + dYYf_0_0[" << i << "][" << s
                << "][" << m << "] * dTf_0_0[" << s << "] + dYTf_0_0[" << i
                << "][" << s << "] * dYf_0_0[" << s << "][" << m
                << "] + dYTf_0_0[" << s << "][" << m << "] * dYf_0_0[" << i
                << "][" << s << "]";
        }
        evalh << "));" << endl;
      }
      evalh << "   HessF[" << m << "][" << NOP << "] = HessF[" << NOP << "]["
            << m << "];" << endl;
      evalh << endl;
    }

    evalh << "   HessF[" << NOP << "][" << NOP << "] = 0.0;" << endl;
    for (int i = 0; i < nop; ++i) {
      evalh << "   HessF[" << NOP << "][" << NOP << "] += 2.0 * ( ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalh << " + dYTf_0_0[" << i << "][" << s << "] * f_0_0[" << s
              << "] + dYf_0_0[" << i << "][" << s << "] * dTf_0_0[" << s << "]";
      }
      evalh << ") * ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalh << " + dYTf_0_0[" << i << "][" << s << "] * f_0_0[" << s
              << "] + dYf_0_0[" << i << "][" << s << "] * dTf_0_0[" << s << "]";
      }
      evalh << ") + (0.0";
      for (int s = 0; s < nop; ++s) {
        evalh << " + dYf_0_0[" << i << "][" << s << "] * f_0_0[" << s << "]";
      }
      evalh << ") * ( 0.0";
      for (int s = 0; s < nop; ++s) {
        evalh << " + dYTTf_0_0[" << i << "][" << s << "] * f_0_0[" << s
              << "] + 2*dYTf_0_0[" << i << "][" << s << "] * dTf_0_0[" << s
              << "] + dTTf_0_0[" << s << "] * dYf_0_0[" << i << "][" << s
              << "]";
      }
      evalh << "));" << endl;
    }

    evalh << endl << endl;

    evalh << "   //mulitply with scaling factor and obj_factor" << endl;
    for (int m = 0; m < NOP + 1; ++m) {
      for (int k = 0; k < NOP + 1; ++k) {
        evalh << "   HessF[" << m << "][" << k << "] *= (scale*obj_factor);"
              << endl;
      }
    }
    evalh << endl;

    evalh
        << "   //add second order derivatives of enthalpy conservation to HessF"
        << endl;
    for (int m = 0; m < NOP; ++m) {
      evalh << "   HessF[" << NOP << "][" << m << "] += lambda["
            << NSTAGES * NOP << "] * (1/Ms[" << Iop[m] - 1 << "] * dTH_0_0["
            << Iop[m] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalh << " + dTH_0_0[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1
              << "] * dYYres_0_0[" << i << "][" << m << "]";
      }
      evalh << ");" << endl;
      evalh << "   HessF[" << m << "][" << NOP << "] += lambda["
            << NSTAGES * NOP << "] * (1/Ms[" << Iop[m] - 1 << "] * dTH_0_0["
            << Iop[m] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalh << " + dTH_0_0[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1
              << "] * dYYres_0_0[" << i << "][" << m << "]";
      }
      evalh << ");" << endl;
      evalh << endl;
    }

    evalh << "   HessF[" << NOP << "][" << NOP << "] += lambda["
          << NSTAGES * NOP << "] * (";
    for (int i = 0; i < nop; ++i) {
      evalh << " + dTTH_0_0[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
            << "] * Y_0_0[" << i << "]";
    }
    for (int i = 0; i < nnop; ++i) {
      evalh << " + dTTH_0_0[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1
            << "] * Yres_0_0[" << i << "]";
    }
    evalh << ");" << endl;
    evalh << endl;

    int valuesH = 0;
    evalh << "   //create first block" << endl;
    for (int i = 0; i < NOP + 1; ++i) {
      for (int j = 0; j < NOP + 1; ++j) {
        evalh << "   values[" << valuesH << "] = HessF[" << i << "][" << j
              << "];" << endl;
        valuesH++;
      }
    }
    evalh << endl;

    evalh << std::setprecision(20);
    int offset = 0, soffset = 1;

    for (int nit = 0; nit <= NINT; ++nit) {

      for (int l = 1; l <= NSTAGES; ++l) {
        evalh << "   //generate Block_" << nit << "_" << l << endl;
        evalh << "   Number Block_" << nit << "_" << l << "[" << NOP + 1 << "]["
              << NOP + 1 << "];" << endl;
        for (int s = 0; s < NOP; ++s) {
          for (int m = 0; m < NOP; ++m) {
            evalh << "   Block_" << nit << "_" << l << "[" << s << "][" << m
                  << "] = -h* (0.0 ";
            for (int i = 0; i < NSTAGES; ++i) {
              for (int k = 0; k < NOP; ++k) {
                evalh << " + (" << A[i][l - 1] << ") * lambda["
                      << offset + i * NOP + k << "] * dYYf_" << nit << "_" << l
                      << "[" << k << "][" << s << "][" << m << "]";
              }
            }
            evalh << ");" << endl;
          }
        }
        evalh << endl;
        for (int s = 0; s < NOP; ++s) {
          evalh << "   Block_" << nit << "_" << l << "[" << s << "][" << NOP
                << "] = -h* (0.0 ";
          for (int i = 0; i < NSTAGES; ++i) {
            for (int k = 0; k < NOP; ++k) {
              evalh << " + (" << A[i][l - 1] << ") * lambda["
                    << offset + i * NOP + k << "] * dYTf_" << nit << "_" << l
                    << "[" << k << "][" << s << "]";
            }
          }
          evalh << ") + lambda[" << offset + NOP * NSTAGES + soffset + l - 1
                << "] * (1/Ms[" << Iop[s] - 1 << "] * dTH_" << nit << "_" << l
                << "[" << Iop[s] - 1 << "]";
          for (int i = 0; i < nnop; ++i) {
            evalh << " + dTH_" << nit << "_" << l << "[" << Inop[i] - 1
                  << "]/Ms[" << Inop[i] - 1 << "] * dYYres_" << nit << "_" << l
                  << "[" << i << "][" << s << "]";
          }
          evalh << "); Block_" << nit << "_" << l << "[" << NOP << "][" << s
                << "] = Block_" << nit << "_" << l << "[" << s << "][" << NOP
                << "];" << endl;
        }
        evalh << endl;

        evalh << "   Block_" << nit << "_" << l << "[" << NOP << "][" << NOP
              << "] = -h* (0.0 ";
        for (int i = 0; i < NSTAGES; ++i) {
          for (int k = 0; k < NOP; ++k) {
            evalh << " + (" << A[i][l - 1] << ") * lambda["
                  << offset + i * NOP + k << "] * dTTf_" << nit << "_" << l
                  << "[" << k << "]";
          }
        }
        evalh << ") + lambda[" << offset + NOP * NSTAGES + soffset + l - 1
              << "] * (";
        for (int i = 0; i < nop; ++i) {
          evalh << " + dTTH_" << nit << "_" << l << "[" << Iop[i] - 1 << "]/Ms["
                << Iop[i] - 1 << "] * Y_" << nit << "_" << l << "[" << i << "]";
        }
        for (int i = 0; i < nnop; ++i) {
          evalh << " + dTTH_" << nit << "_" << l << "[" << Inop[i] - 1
                << "]/Ms[" << Inop[i] - 1 << "] * Yres_" << nit << "_" << l
                << "[" << i << "]";
        }
        evalh << ");" << endl;
        evalh << endl;

        evalh << "   //set block values" << endl;
        for (int i = 0; i < NOP + 1; ++i) {
          for (int j = 0; j < NOP + 1; ++j) {
            evalh << "   values[" << valuesH << "] = Block_" << nit << "_" << l
                  << "[" << i << "][" << j << "];" << endl;
            valuesH++;
          }
        }
        evalh << endl;
      }
      offset += NSTAGES * (NOP + 1);
      if (nit == 0) {
        offset++;
        soffset = 0;
      }
    }

    evalh << "   } // else-block of (values == NULL)" << endl;
  }
  evalh << "   return true;" << endl;
  evalh << "} //eval_h" << endl;
  evalh.close();
}

void generateRates(vector<double> A, vector<double> b, vector<double> Ea,
                   vector<string> species, vector<vector<int>> nuprime,
                   vector<vector<int>> nu2prime, vector<double> Ms,
                   vector<int> forwardReactions, vector<vector<double>> nasa,
                   vector<double> switchingPoints, string format,
                   string filename) {

  // get problem dimensions
  int nreac = A.size();
  int nspec = species.size();

  // generate nu
  vector<vector<int>> nu(nspec, vector<int>(nreac, 0));
  for (int i = 0; i < nu.size(); ++i) {
    for (int k = 0; k < nu[0].size(); ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  if (format.compare("matlab") == 0) {
    ofstream rates("rates.m");
    rates << std::setprecision(15);
    rates << "% Autogenerated file on " << ctime(&t);
    rates << "% rates.m" << endl;
    rates
        << "%    Description: Calculates the forward and reverse reaction rates"
        << endl;
    rates << "%                 based on arrhenius law and thermodynamics as "
             "well as"
          << endl;
    rates << "%                 required derivatives for" << endl;
    rates << "%                 mechanism: " << filename << "." << endl;
    rates << "%    Input: T - temperature." << endl;
    rates << "%    Output: kf - forward rates." << endl;
    rates << "%            kr - reverse rates." << endl;
    rates << "%            dTkf - first derivative of forward rates w.r.t. "
             "temperature."
          << endl;
    rates << "%            dTkr - first derivative of reverse rates w.r.t. "
             "temperature."
          << endl;
    rates << "%            d2Tkf - second derivative of forward rates w.r.t. "
             "temperature."
          << endl;
    rates << "%            d2Tkr - second derivative of reverse rates w.r.t. "
             "temperature."
          << endl;
    rates << "function [kf,kr,dTkf,dTkr,d2Tkf,d2Tkr] = rates(T)" << endl
          << endl;

    rates << "%% Preliminaries" << endl;
    rates << "kf = zeros(" << nreac << ",1);" << endl;
    rates << "kr = zeros(" << nreac << ",1);" << endl;
    rates << "Kp = zeros(" << nreac << ",1);" << endl;
    rates << "Kc = zeros(" << nreac << ",1);" << endl;
    rates << "deltaH = zeros(" << nreac << ",1); \% molar reaction enthalpy"
          << endl;
    rates << "deltaS = zeros(" << nreac << ",1); \% molar reaction entropy"
          << endl;
    rates << "dTkf = zeros(" << nreac << ",1);" << endl;
    rates << "dTkr = zeros(" << nreac << ",1);" << endl;
    rates << "dTKp = zeros(" << nreac << ",1);" << endl;
    rates << "dTKc = zeros(" << nreac << ",1);" << endl;
    rates << "dTdeltaH = zeros(" << nreac << ",1);" << endl;
    rates << "dTdeltaS = zeros(" << nreac << ",1);" << endl;
    rates << "d2Tkf = zeros(" << nreac << ",1);" << endl;
    rates << "d2Tkr = zeros(" << nreac << ",1);" << endl;
    rates << "d2TKp = zeros(" << nreac << ",1);" << endl;
    rates << "d2TKc = zeros(" << nreac << ",1);" << endl;
    rates << "d2TdeltaH = zeros(" << nreac << ",1);" << endl;
    rates << "d2TdeltaS = zeros(" << nreac << ",1);" << endl;
    rates << "gamma  = 20; % transition parameter" << endl;
    rates << "R = 8.3144598;" << endl;
    rates << "p0 = 100000; \% standard pressure = 1 bar = 100000 Pa" << endl;
    rates << "A = [";
    for (int i = 0; i < nreac; ++i) {
      rates << std::setprecision(15) << A[i] << " ";
    }
    rates << "];" << endl;
    rates << "b = [";
    for (int i = 0; i < nreac; ++i) {
      rates << b[i] << " ";
    }
    rates << "];" << endl;
    rates << "Ea = [";
    for (int i = 0; i < nreac; ++i) {
      rates << Ea[i] << " ";
    }
    rates << "];" << endl;

    // generating nasa
    rates << "nasa = [";
    for (int i = 0; i < nspec; ++i) {
      for (int k = 0; k < 14; ++k) {
        rates << nasa[i][k] << " ";
      }
      rates << ";" << endl;
    }
    rates << "]; % coefficients for nasa polynomials - each line: "
             "[a1_low,...,a7_low,a1_high,..,a7_high]"
          << endl;

    // generating switching points
    rates << "T_sw = [";
    for (int k = 0; k < nspec; ++k) {
      rates << switchingPoints[k] << " ";
    }
    rates << "]'; \% switching points between branches" << endl;

    // generating kf
    rates << endl << "%% Calculate forward rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "kf(" << i + 1 << ") = A(" << i + 1 << ") * T^(b(" << i + 1
            << ")) * exp(-Ea(" << i + 1 << ")/(R*T));" << endl;
    }

    // generating Hbar_{low,high}, Sbar_{low,high}
    rates << endl << "%% calculate H_{low,high}, S_{low,high}" << endl;
    rates << "H_low = R*(nasa(:,1)*T + nasa(:,2)/2*T^2 + nasa(:,3)/3*T^3 + "
             "nasa(:,4)/4*T^4 + nasa(:,5)/5*T^5 + nasa(:,6));"
          << endl;
    rates << "H_high = R*(nasa(:,8)*T + nasa(:,9)/2*T^2 + nasa(:,10)/3*T^3 + "
             "nasa(:,11)/4*T^4 + nasa(:,12)/5*T^5 + nasa(:,13));"
          << endl;
    rates << "S_low  = R*(nasa(:,1)*log(T) + nasa(:,2)*T + nasa(:,3)/2*T^2 + "
             "nasa(:,4)/3*T^3 + nasa(:,5)/4*T^4 + nasa(:,7));"
          << endl;
    rates << "S_high = R*(nasa(:,8)*log(T) + nasa(:,9)*T + nasa(:,10)/2*T^2 + "
             "nasa(:,11)/3*T^3 + nasa(:,12)/4*T^4 + nasa(:,14));"
          << endl;

    // generating Hbar, Sbar
    rates << "%% calculate Hbar, Sbar" << endl;
    rates << "sigma = 1/2*tanh(gamma*(T-T_sw)) + 1/2;" << endl;
    rates << "Hbar = (1-sigma).*H_low + sigma.*H_high;" << endl;
    rates << "Sbar = (1-sigma).*S_low + sigma.*S_high;" << endl;

    // generating molar reaction enthalpy, entropy
    rates << "%% calculate deltaH, deltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "deltaH(" << r + 1 << ") = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * Hbar(" << s + 1 << ")";
        }
      }
      rates << ";" << endl << "deltaS(" << r + 1 << ") = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * Sbar(" << s + 1 << ")";
        }
      }
      rates << ";" << endl;
    }

    // generating Kp, Kc
    rates << endl << "%% Calculate equilibrium rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "Kp(" << i + 1 << ") = exp(deltaS(" << i + 1 << ")/R-deltaH("
            << i + 1 << ")/(R*T));" << endl;
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "Kc(" << i + 1 << ") = Kp(" << i + 1 << ") * (p0/(R*T))^(" << nur
            << ");" << endl;
    }

    // generating kr
    rates << endl << "%% Calculate reverse rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "kr(" << i + 1 << ") = kf(" << i + 1 << ")/Kc(" << i + 1 << ");"
            << endl;
    }

    // generating dTkf
    rates << endl << "%% Calculate derivative of kf" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "dTkf(" << i + 1 << ") = A(" << i + 1 << ")*b(" << i + 1
            << ")*T^(b(" << i + 1 << ")-1)*exp(-Ea(" << i + 1 << ")/(R*T)) + A("
            << i + 1 << ")*Ea(" << i + 1 << ")/R*T^(b(" << i + 1
            << ")-2)*exp(-Ea(" << i + 1 << ")/(R*T));" << endl;
    }
    rates << endl;

    // generating dTHbar_{low,high}, Sbar_{low,high}
    rates << "%% calculate dTH_{low,high}, dTS_{low,high}" << endl;
    rates << "dTH_low  = R*(nasa(:,1) + nasa(:,2)*T + nasa(:,3)*T^2 + "
             "nasa(:,4)*T^3 + nasa(:,5)*T^4);"
          << endl;
    rates << "dTH_high = R*(nasa(:,8) + nasa(:,9)*T + nasa(:,10)*T^2 + "
             "nasa(:,11)*T^3 + nasa(:,12)*T^4);"
          << endl;
    rates << "dTS_low  = R*(nasa(:,1)/T + nasa(:,2) + nasa(:,3)*T + "
             "nasa(:,4)*T^2 + nasa(:,5)*T^3);"
          << endl;
    rates << "dTS_high = R*(nasa(:,8)/T + nasa(:,9) + nasa(:,10)*T + "
             "nasa(:,11)*T^2 + nasa(:,12)*T^3);"
          << endl;

    // generating dTHbar, Sbar
    rates << "%% calculate dTHbar, dTSbar" << endl;
    rates << "dTsigma = gamma./(2*cosh(gamma*(T-T_sw)));" << endl;
    rates << "dTHbar = (1-sigma).*dTH_low + sigma.*dTH_high - dTsigma.*H_low + "
             "dTsigma.*H_high;"
          << endl;
    rates << "dTSbar = (1-sigma).*dTS_low + sigma.*dTS_high - dTsigma.*S_low + "
             "dTsigma.*S_high;"
          << endl;

    // generating d/dT of molar reaction enthalpy, entropy
    rates << "%% calculate dTdeltaH, dTdeltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "dTdeltaH(" << r + 1 << ") = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * dTHbar(" << s + 1 << ")";
        }
      }
      rates << ";" << endl << "dTdeltaS(" << r + 1 << ") = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * dTSbar(" << s + 1 << ")";
        }
      }
      rates << ";" << endl;
    }

    // generating d/dT of Kp
    rates << endl << "%% Calculate d/dT of Kp" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "dTKp(" << i + 1 << ") = exp(deltaS(" << i + 1 << ")/R-deltaH("
            << i + 1 << ")/(R*T)) * (1/R * dTdeltaS(" << i + 1
            << ")  - (dTdeltaH(" << i + 1 << ")*T - deltaH(" << i + 1
            << "))/(R*T^2));" << endl;
    }

    // generating d/dT of Kc
    rates << endl << "%% Calculate d/dT of Kc" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "dTKc(" << i + 1 << ") = dTKp(" << i + 1 << ") * (p0/(R*T))^("
            << nur << ") - p0/(R*T^2)*Kp(" << i + 1 << ")*(" << nur
            << ")*(p0/(R*T))^(" << nur - 1 << ");" << endl;
    }

    // generating dTkr
    rates << endl << "%% Calculate derivative of kr" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "dTkr(" << i + 1 << ") = (dTkf(" << i + 1 << ")*Kc(" << i + 1
            << ")-kf(" << i + 1 << ")*dTKc(" << i + 1 << "))/(Kc(" << i + 1
            << ")^2);" << endl;
    }

    // generating d2Tkf
    rates << endl << "%% Calculate 2nd order derivative of kf" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "d2Tkf(" << i + 1 << ") =  ( Ea(" << i + 1 << ")*(2*b(" << i + 1
            << ")-2)/R*T^(b(" << i + 1 << ")-3) + ( b(" << i + 1 << ")*(b("
            << i + 1 << ")-1) + (Ea(" << i + 1 << ")/(R*T))^2) * T^(b(" << i + 1
            << ")-2) ) * A(" << i + 1 << ")*exp(-Ea(" << i + 1 << ")/(R*T));"
            << endl;
    }
    rates << endl;

    // generating d2THbar_{low,high}, d2TSbar_{low,high}
    rates << "%% calculate d2TH_{low,high}, d2TS_{low,high}" << endl;
    rates << "d2TH_low  = R*(nasa(:,2) + 2*nasa(:,3)*T + 3*nasa(:,4)*T^2 + "
             "4*nasa(:,5)*T^3);"
          << endl;
    rates << "d2TH_high = R*(nasa(:,9) + 2*nasa(:,10)*T + 3*nasa(:,11)*T^2 + "
             "4*nasa(:,12)*T^3);"
          << endl;
    rates << "d2TS_low  = R*(-nasa(:,1)/(T^2) + nasa(:,3) + 2*nasa(:,4)*T + "
             "3*nasa(:,5)*T^2);"
          << endl;
    rates << "d2TS_high = R*(-nasa(:,8)/(T^2) + nasa(:,10) + 2*nasa(:,11)*T + "
             "3*nasa(:,12)*T^2);"
          << endl;

    // generating d2THbar, d2TSbar
    rates << "%% calculate d2THbar, d2TSbar" << endl;
    rates << "d2Tsigma = -gamma^2*tanh(gamma*(T-T_sw)) .* "
             "(1-tanh(gamma*(T-T_sw)).^2);"
          << endl;
    rates << "d2THbar = (1-sigma).*d2TH_low -2*dTsigma.*dTH_low - "
             "d2Tsigma.*H_low + sigma.*d2TH_high + 2*dTsigma.*dTH_high + "
             "d2Tsigma.*H_high;"
          << endl;
    rates << "d2TSbar = (1-sigma).*d2TS_low -2*dTsigma.*dTS_low - "
             "d2Tsigma.*S_low + sigma.*d2TS_high + 2*dTsigma.*dTS_high + "
             "d2Tsigma.*S_high;"
          << endl;

    // generating d2/d2T of molar reaction enthalpy, entropy
    rates << "%% calculate d2TdeltaH, d2TdeltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "d2TdeltaH(" << r + 1 << ") = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * d2THbar(" << s + 1 << ")";
        }
      }
      rates << ";" << endl << "d2TdeltaS(" << r + 1 << ") = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * d2TSbar(" << s + 1 << ")";
        }
      }
      rates << ";" << endl;
    }

    // generating d2/d2T of Kp
    rates << endl << "%% Calculate d2/d2T of Kp" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "d2TKp(" << i + 1 << ") = 1/R*exp(deltaS(" << i + 1
            << ")/R-deltaH(" << i + 1 << ")/(R*T)) * ( 1/R * (dTdeltaS("
            << i + 1 << ")  - 1/T * dTdeltaH(" << i + 1 << ") + deltaH("
            << i + 1 << ")/(T*T))^2 + d2TdeltaS(" << i + 1
            << ") + 2/(T*T)* dTdeltaH(" << i + 1 << ") - 1/T*d2TdeltaH("
            << i + 1 << ") - 2/(T*T*T)*deltaH(" << i + 1 << "));" << endl;
    }

    // generating d2/d2T of Kc
    rates << endl << "%% Calculate d2/d2T of Kc" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "d2TKc(" << i + 1 << ") = d2TKp(" << i + 1 << ") * (p0/(R*T))^("
            << nur << ")";
      if (nur != 0) {
        rates << "+ Kp(" << i + 1 << ") * (p0/R)^(" << nur << ") * (" << nur
              << ")*(" << nur + 1 << ")/T^(" << nur + 2 << ") - 2*(" << nur
              << ")/T^(" << nur + 1 << ") * dTKp(" << i + 1 << ")*(p0/R)^("
              << nur << ")";
      }
      rates << ";" << endl;
    }

    // generating dTkr
    rates << endl << "%% Calculate 2nd order derivative of kr" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "d2Tkr(" << i + 1 << ") = ( (d2Tkf(" << i + 1 << ")*Kc(" << i + 1
            << ")-kf(" << i + 1 << ")*d2TKc(" << i + 1 << "))*Kc(" << i + 1
            << ")^2 - 2*Kc(" << i + 1 << ")*dTKc(" << i + 1 << ")*(dTkf("
            << i + 1 << ")*Kc(" << i + 1 << ") - kf(" << i + 1 << ")*dTKc("
            << i + 1 << ")) )/(Kc(" << i + 1 << ")^4);" << endl;
    }

    // set reverse rates of each forward reaction to zero
    rates << endl
          << "%% Set for each forward reaction the reverse rate and their "
             "derivatives to zero"
          << endl;
    for (int i = 0; i < forwardReactions.size(); ++i) {
      rates << "kr(" << forwardReactions[i] + 1 << ") = 0;" << endl;
      rates << "dTkr(" << forwardReactions[i] + 1 << ") = 0;" << endl;
      rates << "d2Tkr(" << forwardReactions[i] + 1 << ") = 0;" << endl;
    }

    rates.close();
    /*
     *   Parse to c++ format.
     *
     *
     */

  } else if (format.compare("c++") == 0) {
    ofstream rates("rates.hpp");
    rates << "/* Autogenerated file on " << ctime(&t);
    rates << " *    Function which returns reaction rates and their "
             "derivatives based on arrhenius law and thermodynamics"
          << endl;
    rates << " *    Mechanism: " << filename << endl;
    rates << " */" << endl;
    rates << std::setprecision(15);
    rates << "void ammsockNLP::rates(Number T, Number kf[" << nreac
          << "],  Number kr[" << nreac << "], Number dTkf[" << nreac
          << "], Number dTkr[" << nreac << "], Number d2Tkf[" << nreac
          << "], Number d2Tkr[" << nreac << "], Number Hbar[" << nspec
          << "], Number dTHbar[" << nspec << "], Number d2THbar[" << nspec
          << "]) {" << endl
          << endl;

    rates << "   // Preliminaries" << endl;
    rates << "   int nreac = (int) " << nreac << ";" << endl;
    rates << "   int nspec = (int) " << nspec << ";" << endl;
    rates << "   Number A[nreac];      // preexponential coefficient" << endl;
    rates << "   Number b[nreac];      // exponent for T in arrhenius low"
          << endl;
    rates << "   Number Ea[nreac];     // activation energy in J" << endl;
    rates
        << "   Number H_low[nspec];  // standard molar enthalpy for low branche"
        << endl;
    rates << "   Number H_high[nspec]; // standard molar enthalpy for high "
             "branche"
          << endl;
    rates
        << "   Number S_low[nspec];  // standard molar entropy for low branche"
        << endl;
    rates
        << "   Number S_high[nspec]; // standard molar entropy for high branche"
        << endl;
    rates
        << "   Number Sbar[nspec];   // standard molar entropy for all branches"
        << endl;
    rates << "   Number deltaH[nreac]; // molar reaction enthalpy" << endl;
    rates << "   Number deltaS[nreac]; // molar reaction entropy" << endl;
    rates << "   Number Kp[nreac];" << endl;
    rates << "   Number Kc[nreac];" << endl;
    rates << "   Number dTH_low[nspec];" << endl;
    rates << "   Number dTH_high[nspec];" << endl;
    rates << "   Number dTS_low[nspec];" << endl;
    rates << "   Number dTS_high[nspec];" << endl;
    rates << "   Number dTSbar[nspec];" << endl;
    rates << "   Number dTdeltaH[nreac];" << endl;
    rates << "   Number dTdeltaS[nreac];" << endl;
    rates << "   Number dTKp[nreac];" << endl;
    rates << "   Number dTKc[nreac];" << endl;
    rates << "   Number d2TH_low[nspec];" << endl;
    rates << "   Number d2TH_high[nspec];" << endl;
    rates << "   Number d2TS_low[nspec];" << endl;
    rates << "   Number d2TS_high[nspec];" << endl;
    rates << "   Number d2TSbar[nspec];" << endl;
    rates << "   Number d2TdeltaH[nreac];" << endl;
    rates << "   Number d2TdeltaS[nreac];" << endl;
    rates << "   Number d2TKp[nreac];" << endl;
    rates << "   Number d2TKc[nreac];" << endl;
    rates << "   Number T_sw[nspec];" << endl;
    rates << "   Number nasa[nspec][14];" << endl;
    rates << "   Number gamma  = 20; // transition parameter" << endl;
    rates << "   Number R = 8.3144598;" << endl;
    rates << "   Number p0 = 100000; // standard pressure" << endl;

    rates << endl << "   //generating A" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   A[" << i << "] = " << A[i] << "; " << endl;
    }

    rates << endl << "   //generating b" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   b[" << i << "] = " << b[i] << "; " << endl;
    }

    rates << endl << "   //generating Ea" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   Ea[" << i << "] = " << Ea[i] << "; " << endl;
    }

    // generating nasa
    rates << endl
          << "   //coefficients nasa polynomials - each row: "
             "[a1_low,...,a7_low,a1_high,..,a7_high]";
    for (int i = 0; i < nspec; ++i) {
      rates << "   // coefficients for specie " << i + 1 << endl;
      for (int k = 0; k < 14; ++k) {
        rates << "   nasa[" << i << "][" << k << "] = " << nasa[i][k] << ";"
              << endl;
      }
      rates << endl;
    }

    // generating switching points
    rates
        << "   //generating switching points for different temperature branches"
        << endl;
    for (int k = 0; k < nspec; ++k) {
      rates << "   T_sw[" << k << "] = " << switchingPoints[k] << ";" << endl;
    }

    // generating kf
    rates << endl << endl << "   //calculate forward rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   kf[" << i << "] = A[" << i << "] * pow(T,b[" << i
            << "]) * exp(-Ea[" << i << "]/(R*T));" << endl;
    }

    // generating Hbar_{low,high}, Sbar_{low,high}
    rates << endl << "   //calculate H_{low,high}, S_{low,high}" << endl;
    rates << "   for (int i = 0; i < nspec; ++i) {" << endl;
    rates << "      H_low[i]  = R*(nasa[i][0]*T + nasa[i][1]/2.0*pow(T,2) + "
             "nasa[i][2]/3.0*pow(T,3) + nasa[i][3]/4.0*pow(T,4) + "
             "nasa[i][4]/5.0*pow(T,5) + nasa[i][5]);"
          << endl;
    rates << "      H_high[i] = R*(nasa[i][7]*T + nasa[i][8]/2.0*pow(T,2) + "
             "nasa[i][9]/3.0*pow(T,3) + nasa[i][10]/4.0*pow(T,4) + "
             "nasa[i][11]/5.0*pow(T,5) + nasa[i][12]);"
          << endl;
    rates << "      S_low[i]  = R*(nasa[i][0]*log(T) + nasa[i][1]*T + "
             "nasa[i][2]/2.0*pow(T,2) + nasa[i][3]/3.0*pow(T,3) + "
             "nasa[i][4]/4.0*pow(T,4) + nasa[i][6]);"
          << endl;
    rates << "      S_high[i] = R*(nasa[i][7]*log(T) + nasa[i][8]*T + "
             "nasa[i][9]/2.0*pow(T,2) + nasa[i][10]/3.0*pow(T,3) + "
             "nasa[i][11]/4.0*pow(T,4) + nasa[i][13]);"
          << endl;
    rates << "   }" << endl;

    // generating Hbar, Sbar
    rates << endl << "   //calculate Hbar, Sbar" << endl;
    rates << "   Number sigma = 0.0;" << endl;
    rates << "   for (int i = 0; i < nspec; ++i) {" << endl;
    rates << "      sigma = 1/2.0*tanh(gamma*(T-T_sw[i])) + 1/2.0;" << endl;
    rates << "      Hbar[i] = (1-sigma)*H_low[i] + sigma*H_high[i];" << endl;
    rates << "      Sbar[i] = (1-sigma)*S_low[i] + sigma*S_high[i];" << endl;
    rates << "   }" << endl;

    // generating molar reaction enthalpy, entropy
    rates << endl << "   //calculate deltaH, deltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "   deltaH[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * Hbar[" << s << "]";
        }
      }
      rates << ";" << endl << "   deltaS[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * Sbar[" << s << "]";
        }
      }
      rates << ";" << endl;
    }

    // generating K_p and K_c
    rates << endl << endl << "   //calculate equilibrium rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   Kp[" << i << "] = exp(deltaS[" << i << "]/R-deltaH[" << i
            << "]/(R*T));" << endl;
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "   Kc[" << i << "] = Kp[" << i << "] * pow(p0/(R*T)," << nur
            << ");" << endl;
    }

    // generating kr
    rates << endl << endl << "   //calculate reverse rates" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   kr[" << i << "] = kf[" << i << "]/Kc[" << i << "];" << endl;
    }

    // generating dTkf
    rates << endl << "   // Calculate derivative of kf" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   dTkf[" << i << "] = A[" << i << "]*b[" << i << "]*pow(T,b["
            << i << "]-1)*exp(-Ea[" << i << "]/(R*T)) + A[" << i << "]*Ea[" << i
            << "]/R*pow(T,b[" << i << "]-2)*exp(-Ea[" << i << "]/(R*T));"
            << endl;
    }
    rates << endl;

    // generating dTHbar_{low,high}, dTSbar_{low,high}
    rates << "   // calculate dTH_{low,high}, dTS_{low,high}" << endl;
    rates << "   for (int i=0; i <" << nspec << "; ++i) {" << endl;
    rates
        << "         dTH_low[i]  = R*(nasa[i][0]   + nasa[i][1]*T + "
           "nasa[i][2]*pow(T,2) + nasa[i][3] *pow(T,3) + nasa[i][4] *pow(T,4));"
        << endl;
    rates
        << "         dTH_high[i] = R*(nasa[i][7]   + nasa[i][8]*T + "
           "nasa[i][9]*pow(T,2) + nasa[i][10]*pow(T,3) + nasa[i][11]*pow(T,4));"
        << endl;
    rates
        << "         dTS_low[i]  = R*(nasa[i][0]/T + nasa[i][1]   + "
           "nasa[i][2]*T        + nasa[i][3] *pow(T,2) + nasa[i][4] *pow(T,3));"
        << endl;
    rates
        << "         dTS_high[i] = R*(nasa[i][7]/T + nasa[i][8]   + "
           "nasa[i][9]*T        + nasa[i][10]*pow(T,2) + nasa[i][11]*pow(T,3));"
        << endl;
    rates << "   }" << endl << endl;

    // generating dTHbar, dTSbar
    rates << "   // calculate dTHbar, dTSbar" << endl;
    rates << "   Number dTsigma = 0.0;" << endl;
    rates << "   for (int i=0; i <" << nspec << "; ++i) {" << endl;
    rates << "      sigma = 1.0/2*tanh(gamma*(T-T_sw[i])) + 1/2.0;" << endl;
    rates << "      dTsigma = gamma/(2*cosh(gamma*(T-T_sw[i])));" << endl;
    rates << "      dTHbar[i] = (1-sigma)*dTH_low[i] + sigma*dTH_high[i] - "
             "dTsigma*H_low[i] + dTsigma*H_high[i];"
          << endl;
    rates << "      dTSbar[i] = (1-sigma)*dTS_low[i] + sigma*dTS_high[i] - "
             "dTsigma*S_low[i] + dTsigma*S_high[i];"
          << endl;
    rates << "   }" << endl << endl;

    // generating d/dT of molar reaction enthalpy, entropy
    rates << "   // calculate dTdeltaH, dTdeltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "   dTdeltaH[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * dTHbar[" << s << "]";
        }
      }
      rates << ";" << endl << "   dTdeltaS[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * dTSbar[" << s << "]";
        }
      }
      rates << ";" << endl;
    }

    // generating d/dT of Kp
    rates << endl << "   // Calculate d/dT of Kp" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   dTKp[" << i << "] = exp(deltaS[" << i << "]/R-deltaH[" << i
            << "]/(R*T)) * (1/R * dTdeltaS[" << i << "]  - (dTdeltaH[" << i
            << "]*T - deltaH[" << i << "])/(R*T*T));" << endl;
    }

    // generating d/dT of Kc
    rates << endl << "   // Calculate d/dT of Kc" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "   dTKc[" << i << "] = dTKp[" << i << "] * pow(p0/(R*T)," << nur
            << ") - p0/(R*T*T)*Kp[" << i << "]*(" << nur << ")*pow(p0/(R*T),"
            << nur - 1 << ");" << endl;
    }

    // generating dTkr
    rates << endl << "   // Calculate derivative of kr" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   dTkr[" << i << "] = (dTkf[" << i << "]*Kc[" << i << "]-kf["
            << i << "]*dTKc[" << i << "])/pow(Kc[" << i << "],2);" << endl;
    }

    /*
     *   Calculate 2nd order derivatives
     */

    // generating d2Tkf
    rates << endl << "   // Calculate 2nd derivative of kf" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   d2Tkf[" << i << "] = ( Ea[" << i << "]*(2*b[" << i
            << "]-2)/R*pow(T,b[" << i << "]-3) + ( b[" << i << "]*(b[" << i
            << "]-1) + pow(Ea[" << i << "]/(R*T),2) )*pow(T,b[" << i
            << "]-2) ) * A[" << i << "]*exp(-Ea[" << i << "]/(R*T));" << endl;
    }
    rates << endl;

    // generating d2THbar_{low,high}, d2TSbar_{low,high}
    rates << "   // calculate d2TH_{low,high}, d2TS_{low,high}" << endl;
    rates << "   for (int i=0; i <" << nspec << "; ++i) {" << endl;
    rates << "         d2TH_low[i]  = R*(nasa[i][1] + 2*nasa[i][2]*T + "
             "3*nasa[i][3] *pow(T,2) + 4*nasa[i][4] *pow(T,3));"
          << endl;
    rates << "         d2TH_high[i] = R*(nasa[i][8] + 2*nasa[i][9]*T + "
             "3*nasa[i][10]*pow(T,2) + 4*nasa[i][11]*pow(T,3));"
          << endl;
    rates << "         d2TS_low[i]  = R*(-nasa[i][0]/(T*T) + nasa[i][2] + "
             "2*nasa[i][3]*T  + 3*nasa[i][4]*pow(T,2));"
          << endl;
    rates << "         d2TS_high[i] = R*(-nasa[i][7]/(T*T) + nasa[i][9] + "
             "2*nasa[i][10]*T + 3*nasa[i][11]*pow(T,2));"
          << endl;
    rates << "   }" << endl << endl;

    // generating d2THbar, d2TSbar
    rates << "   // calculate dTHbar, dTSbar" << endl;
    rates << "   Number d2Tsigma = 0.0;" << endl;
    rates << "   for (int i=0; i <" << nspec << "; ++i) {" << endl;
    rates << "      sigma = 1.0/2*tanh(gamma*(T-T_sw[i])) + 1/2.0;" << endl;
    rates << "      dTsigma = gamma/(2*cosh(gamma*(T-T_sw[i])));" << endl;
    rates << "      d2Tsigma = "
             "-gamma*gamma*tanh(gamma*(T-T_sw[i]))*(1-tanh(gamma*(T-T_sw[i]))*"
             "tanh(gamma*(T-T_sw[i])));"
          << endl;
    rates << "      d2THbar[i] = (1-sigma)*d2TH_low[i] -2*dTsigma*dTH_low[i] - "
             "d2Tsigma*H_low[i] + sigma*d2TH_high[i] + 2*dTsigma*dTH_high[i] + "
             "d2Tsigma*H_high[i];"
          << endl;
    rates << "      d2TSbar[i] = (1-sigma)*d2TS_low[i] -2*dTsigma*dTS_low[i] - "
             "d2Tsigma*S_low[i] + sigma*d2TS_high[i] + 2*dTsigma*dTS_high[i] + "
             "d2Tsigma*S_high[i];"
          << endl;
    rates << "   }" << endl << endl;

    // generating d2/d2T of molar reaction enthalpy, entropy
    rates << "   // calculate dTdeltaH, dTdeltaS" << endl;
    for (int r = 0; r < nreac; ++r) {
      rates << "   d2TdeltaH[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * d2THbar[" << s << "]";
        }
      }
      rates << ";" << endl << "   d2TdeltaS[" << r << "] = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        if (nu[s][r] != 0) {
          rates << " + (" << nu[s][r] << ") * d2TSbar[" << s << "]";
        }
      }
      rates << ";" << endl;
    }

    // generating d2/d2T of Kp
    rates << endl << "   // Calculate d2/d2T of Kp" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   d2TKp[" << i << "] = 1/R*exp(deltaS[" << i << "]/R-deltaH["
            << i << "]/(R*T)) * ( 1/R * pow(dTdeltaS[" << i
            << "]  - 1/T * dTdeltaH[" << i << "] + deltaH[" << i
            << "]/(T*T),2) + d2TdeltaS[" << i << "] + 2/(T*T)* dTdeltaH[" << i
            << "] - 1/T*d2TdeltaH[" << i << "] - 2/(T*T*T)*deltaH[" << i
            << "]);" << endl;
    }

    // generating d2/d2T of Kc
    rates << endl << "   // Calculate d2/d2T of Kc" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nur = 0;
      for (int s = 0; s < nspec; ++s) {
        nur = nur + nu[s][i];
      }
      rates << "   d2TKc[" << i << "] = d2TKp[" << i << "] * pow(p0/(R*T),"
            << nur << ")";
      if (nur != 0) {
        rates << " + Kp[" << i << "] * pow(p0/R," << nur << ") * (" << nur
              << ")*(" << nur + 1 << ")/pow(T," << nur + 2 << ") - 2*(" << nur
              << ")/pow(T," << nur + 1 << ") * dTKp[" << i << "]*pow(p0/R,"
              << nur << ")";
      }
      rates << ";" << endl;
    }

    // generating d2Tkr
    rates << endl << "   // Calculate 2nd order derivative of kr" << endl;
    for (int i = 0; i < nreac; ++i) {
      rates << "   d2Tkr[" << i << "] = ( (d2Tkf[" << i << "]*Kc[" << i
            << "]-kf[" << i << "]*d2TKc[" << i << "])*pow(Kc[" << i
            << "],2) - 2*Kc[" << i << "]*dTKc[" << i << "]*(dTkf[" << i
            << "]*Kc[" << i << "] - kf[" << i << "]*dTKc[" << i
            << "]) )/pow(Kc[" << i << "],4);" << endl;
    }

    // set reverse rates of each forward reaction to zero
    rates << endl
          << "   //Set for each forward reaction the reverse rate and their "
             "derivatives to zero"
          << endl;
    for (int i = 0; i < forwardReactions.size(); ++i) {
      rates << "   kr[" << forwardReactions[i] << "] = 0.0;" << endl;
      rates << "   dTkr[" << forwardReactions[i] << "] = 0.0;" << endl;
      rates << "   d2Tkr[" << forwardReactions[i] << "] = 0.0;" << endl;
    }

    // close function and file
    rates << endl << "}";
    rates.close();
  } else {
    cerr << "Format unkwown. Please choose either 'matlab' or 'c++'." << endl;
  }
}

void generateEvalG(vector<string> species, vector<vector<int>> nuprime,
                   vector<vector<int>> nu2prime,
                   vector<vector<double>> consMatrix, vector<double> Ms,
                   vector<int> bodyPos, vector<int> bodyNumber,
                   vector<vector<double>> bodyCoeff, string filename) {

  // set collocation schema
  double A[NSTAGES][NSTAGES] = ACOLL;

  // get problem dimensions
  int nop = NOP;
  int nnop = NNOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;
  int nspec = species.size();
  int nreac = nuprime[0].size();
  int natom = consMatrix.size();
  int offset = 0;

  int nu[nspec][nreac];
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < nreac; ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalg("eval_g.hpp");
  evalg << setprecision(15);
  evalg << "/* Autogenerated file on " << ctime(&t);
  evalg << " *    Function defining the contraints of collocation, mass and "
           "enthalpy conservation"
        << endl;
  evalg << " *    Mechanism: " << filename << endl;
  evalg << " */" << endl;
  evalg << "bool ammsockNLP::eval_g(Index n, const Number* x, bool new_x, "
           "Index m, Number* g) {"
        << endl
        << endl;

  // rename variables
  evalg << endl << "   //set variables " << endl;
  evalg << "   Number Y_0_0[" << nop << "] = { x[0]";
  for (int i = 1; i < nop; ++i) {
    evalg << ",  x[" << i << "]";
  }
  evalg << "}, T_0_0 = x[" << nop << "];" << endl;

  for (int k = 0; k <= NINT; ++k) {
    for (int s = 1; s <= NSTAGES; ++s) {
      evalg << "   Number Y_" << k << "_" << s << "[" << nop << "] = { x["
            << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + 1 << "]";
      for (int i = 1; i < nop; ++i) {
        evalg << ", x["
              << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + i + 1
              << "]";
      }
      evalg << "}, T_" << k << "_" << s << " = x["
            << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + nop + 1
            << "];" << endl;
    }
  }
  evalg << endl;

  evalg << "   // Preliminaries: set molar weights, get f and H - coding "
           "NAME_INTERVAL_STAGE"
        << endl;
  evalg << "   Number Ms[" << nspec << "] = { " << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;

  evalg << "   Number f_0_0[" << nop << "],";
  for (int k = 0; k < NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << " f_" << k << "_" << i << "[" << nop << "],";
    }
  }
  for (int i = 1; i < NSTAGES; ++i) {
    evalg << " f_" << NINT << "_" << i << "[" << nop << "],";
  }
  evalg << " f_" << NINT << "_" << NSTAGES << "[" << nop << "];" << endl;
  evalg << "   Number H_0_0[" << nspec << "],";
  for (int k = 0; k < NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << " H_" << k << "_" << i << "[" << nspec << "],";
    }
  }
  for (int i = 1; i < NSTAGES; ++i) {
    evalg << " H_" << NINT << "_" << i << "[" << nspec << "],";
  }
  evalg << " H_" << NINT << "_" << NSTAGES << "[" << nspec << "];" << endl;
  evalg << "   Number Yres_0_0[" << nnop << "],";
  for (int k = 0; k < NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << " Yres_" << k << "_" << i << "[" << nnop << "],";
    }
  }
  for (int i = 1; i < NSTAGES; ++i) {
    evalg << " Yres_" << NINT << "_" << i << "[" << nnop << "],";
  }
  evalg << " Yres_" << NINT << "_" << NSTAGES << "[" << nnop << "];" << endl;
  evalg << endl;

  evalg << "   get_f(T_0_0, Y_0_0, f_0_0, H_0_0, Yres_0_0);" << endl;
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << "   get_f(T_" << k << "_" << i << ", Y_" << k << "_" << i
            << ", f_" << k << "_" << i << ", H_" << k << "_" << i << ", Yres_"
            << k << "_" << i << ");" << endl;
    }
  }
  evalg << endl;

  // generating constraint function g
  evalg << "   //generating constraint function g" << endl;
  evalg << std::setprecision(15);
  // generate stages approximations
  for (int i = 1; i <= NSTAGES; ++i) {
    for (int s = 0; s < nop; ++s) {
      evalg << "   g[" << (i - 1) * nop + s << "] = Y_0_" << i << "[" << s
            << "] - Y_0_0[" << s << "] - h* ( 0.0";
      for (int j = 1; j <= NSTAGES; ++j) {
        evalg << " + (" << A[i - 1][j - 1] << ") * f_0_" << j << "[" << s
              << "]";
      }
      evalg << ");" << endl;
    }
  }

  // generate enthalpy conservation for each stage
  evalg << "   g[" << NSTAGES * nop << "] = -hFixed";
  for (int s = 0; s < nop; ++s) {
    evalg << " + H_0_0[" << Iop[s] - 1 << "] * Y_0_0[" << s << "]/Ms["
          << Iop[s] - 1 << "]";
  }
  for (int s = 0; s < nnop; ++s) {
    evalg << " + H_0_0[" << Inop[s] - 1 << "] * Yres_0_0[" << s << "]/Ms["
          << Inop[s] - 1 << "]";
  }
  evalg << ";" << endl;
  for (int i = 1; i <= NSTAGES; ++i) {
    evalg << "   g[" << NSTAGES * nop + i << "] = -hFixed";
    for (int s = 0; s < nop; ++s) {
      evalg << " + H_0_" << i << "[" << Iop[s] - 1 << "] * Y_0_" << i << "["
            << s << "]/Ms[" << Iop[s] - 1 << "]";
    }
    for (int s = 0; s < nnop; ++s) {
      evalg << " + H_0_" << i << "[" << Inop[s] - 1 << "] * Yres_0_" << i << "["
            << s << "]/Ms[" << Inop[s] - 1 << "]";
    }
    evalg << ";" << endl;
  }

  // generate collocations schema for each intervall
  offset = NSTAGES * (nop + 1) + 1;
  for (int k = 1; k <= NINT; ++k) {
    // generate stages approximations
    for (int i = 1; i <= NSTAGES; ++i) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   g["
              << offset + (k - 1) * NSTAGES * (nop + 1) + (i - 1) * nop + s
              << "] = Y_" << k << "_" << i << "[" << s << "] - Y_" << k - 1
              << "_" << NSTAGES << "[" << s << "] - h* ( 0.0";
        for (int j = 1; j <= NSTAGES; ++j) {
          evalg << " + (" << A[i - 1][j - 1] << ") * f_" << k << "_" << j << "["
                << s << "]";
        }
        evalg << ");" << endl;
      }
    }

    // generate enthalpy conservation for each stage
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << "   g["
            << offset + (k - 1) * NSTAGES * (nop + 1) + NSTAGES * nop + i - 1
            << "] = -hFixed";
      for (int s = 0; s < nop; ++s) {
        evalg << " + H_" << k << "_" << i << "[" << Iop[s] - 1 << "] * Y_" << k
              << "_" << i << "[" << s << "]/Ms[" << Iop[s] - 1 << "]";
      }
      for (int s = 0; s < nnop; ++s) {
        evalg << " + H_" << k << "_" << i << "[" << Inop[s] - 1 << "] * Yres_"
              << k << "_" << i << "[" << s << "]/Ms[" << Inop[s] - 1 << "]";
      }
      evalg << ";" << endl;
    }
  }

  // generate mass conservation for y(t_f) if there is no NNOP
  offset = offset + (NINT - 1) * NSTAGES * (nop + 1) + NSTAGES * nop + NSTAGES;
  if (NNOP == 0) {
    for (int a = 0; a < natom; ++a) {
      evalg << "   g[" << offset + a << "] = -consAtom[" << a << "]";
      for (int s = 0; s < nop; ++s) {
        if (consMatrix[a][s] != 0) {
          evalg << setprecision(15) << " + " << consMatrix[a][s] << " * Y_"
                << NINT << "_" << NSTAGES << "[" << s << "]";
        }
      }
      evalg << ";" << endl;
    }
    offset += natom;
  }

  // generate fixation of reaction progress variables
  for (int i = 0; i < NRPV; ++i) {
    evalg << "   g[" << offset + i << "] = -rpv_fixed[" << i << "] + Y_" << NINT
          << "_" << NSTAGES << "[rpv_index[" << i << "]];" << endl;
  }
  offset += NRPV;

  // generate nontrivial inequalities
  for (int s = 0; s <= NSTAGES; ++s) {
    for (int i = 0; i < NNOP; ++i) {
      evalg << "   g[" << offset << "] = Yres_0_" << s << "[" << i << "];"
            << endl;
      offset++;
    }
  }
  for (int k = 1; k <= NINT; ++k) {
    for (int s = 1; s <= NSTAGES; ++s) {
      for (int i = 0; i < NNOP; ++i) {
        evalg << "   g[" << offset << "] = Yres_" << k << "_" << s << "[" << i
              << "];" << endl;
        offset++;
      }
    }
  }

  // close function and file
  evalg << endl << "   return true;" << endl;
  evalg << endl << "}";
  evalg.close();
}

void generateEvalJacG(vector<string> species, vector<vector<int>> nuprime,
                      vector<vector<int>> nu2prime,
                      vector<vector<double>> consMatrix, vector<double> Ms,
                      vector<int> bodyPos, vector<int> bodyNumber,
                      vector<vector<double>> bodyCoeff, string filename) {

  // set collocation schema
  double A[NSTAGES][NSTAGES] = ACOLL;

  // get problem dimensions
  int nspec = species.size();
  int nreac = nuprime[0].size();
  int natom = consMatrix.size();
  int nop = NOP;
  int nnop = NNOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;

  int nu[nspec][nreac];
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < nreac; ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalg("eval_jac_g.hpp");
  evalg << setprecision(15);
  evalg << "/* Autogenerated file on " << ctime(&t);
  evalg << " *    Function defining the structure as well as the values of the "
           "Jacobian of the contraints"
        << endl;
  evalg << " *    Mechanism: " << filename << endl;
  evalg << " */" << endl;
  evalg
      << "bool ammsockNLP::eval_jac_g(Index n, const Number* x, bool new_x, "
         "Index m, Index nele_jac, Index* iRow, Index *jCol, Number* values) {"
      << endl
      << endl;
  evalg << "   // returns structure of jacobian" << endl;
  evalg << "   if (values == NULL) {" << endl;
  int nnzJacG = 0;
  int offset = 0;
  evalg << "      //set index for first intervall: stage approximations"
        << endl;
  for (int s = 1; s <= NSTAGES; ++s) {
    for (int i = 1; i <= nop; ++i) {
      evalg << "      iRow[" << nnzJacG << "] = " << (s - 1) * nop + i
            << "; jCol[" << nnzJacG << "] = " << i << ";" << endl;
      nnzJacG++;
      for (int k = 1; k <= NSTAGES * (nop + 1); ++k) {
        evalg << "      iRow[" << nnzJacG << "] = " << (s - 1) * nop + i
              << "; jCol[" << nnzJacG << "] = " << nop + 1 + k << ";" << endl;
        nnzJacG++;
      }
    }
  }
  evalg << "      //set index for first intervall: enthalpy conservations"
        << endl;
  for (int i = 1; i <= NSTAGES + 1; ++i) {
    for (int s = 1; s <= nop + 1; ++s) {
      evalg << "      iRow[" << nnzJacG << "] = " << NSTAGES * nop + i
            << "; jCol[" << nnzJacG << "] = " << (i - 1) * (nop + 1) + s << ";"
            << endl;
      nnzJacG++;
    }
  }

  for (int k = 1; k <= NINT; ++k) {
    evalg << "      //set index for intervall " << k + 1
          << ": stage approximations" << endl;
    for (int s = 1; s <= NSTAGES; ++s) {
      for (int i = 1; i <= nop; ++i) {
        evalg << "      iRow[" << nnzJacG
              << "] = " << 1 + k * NSTAGES * (nop + 1) + (s - 1) * nop + i
              << "; jCol[" << nnzJacG << "] = "
              << (nop + 1) + (k - 1) * (nop + 1) * NSTAGES +
                     (NSTAGES - 1) * (nop + 1) + i
              << ";" << endl;
        nnzJacG++;
        for (int j = 1; j <= NSTAGES * (nop + 1); ++j) {
          evalg << "      iRow[" << nnzJacG
                << "] = " << 1 + k * NSTAGES * (nop + 1) + (s - 1) * nop + i
                << "; jCol[" << nnzJacG << "] = "
                << (nop + 1) + (k - 1) * (nop + 1) * NSTAGES +
                       NSTAGES * (nop + 1) + j
                << ";" << endl;
          nnzJacG++;
        }
      }
    }

    evalg << "      //set index for intervall " << k + 1
          << ": enthalpy conservations" << endl;
    for (int i = 1; i <= NSTAGES; ++i) {
      for (int s = 1; s <= nop + 1; ++s) {
        evalg << "      iRow[" << nnzJacG
              << "] = " << 1 + k * NSTAGES * (nop + 1) + NSTAGES * nop + i
              << "; jCol[" << nnzJacG << "] = "
              << (nop + 1) + (k - 1) * (nop + 1) * NSTAGES +
                     NSTAGES * (nop + 1) + (i - 1) * (nop + 1) + s
              << ";" << endl;
        nnzJacG++;
      }
    }
  }

  if (NNOP == 0) {
    evalg << "      //set index for mass conservations" << endl;
    for (int a = 1; a <= natom; ++a) {
      for (int s = 1; s <= nop; ++s) {
        //	if (consMatrix[a-1][s-1] != 0) {
        evalg << "      iRow[" << nnzJacG << "] = "
              << 1 + NINT * NSTAGES * (nop + 1) + NSTAGES * nop + NSTAGES + a
              << "; jCol[" << nnzJacG << "] = "
              << (nop + 1) + NINT * (nop + 1) * NSTAGES +
                     (NSTAGES - 1) * (nop + 1) + s
              << ";" << endl;
        nnzJacG++;
        //	}
      }
    }
    offset += natom;
  }

  evalg << "      //set index for fixation of reaction progress variables"
        << endl;
  for (int i = 0; i < NRPV; ++i) {
    evalg << "      iRow[" << nnzJacG << "] = "
          << 1 + NINT * NSTAGES * (nop + 1) + NSTAGES * nop + NSTAGES + offset +
                 i + 1
          << "; jCol[" << nnzJacG << "] = "
          << (nop + 1) + NINT * (nop + 1) * NSTAGES + (NSTAGES - 1) * (nop + 1)
          << "+rpv_index[" << i << "]+1;" << endl;
    nnzJacG++;
  }
  offset = 1 + NINT * NSTAGES * (nop + 1) + NSTAGES * nop + NSTAGES + offset +
           NRPV + 1;
  /*
          evalg << "   //set index for nontrivial inequalities" << endl;
          for (int i = 0; i < nnop; ++i) {
                  for (int s = 0; s < nop; ++s) {
                          evalg << "      iRow["<<nnzJacG<<"] = "<<offset+i<<";
     jCol["<<nnzJacG<<"] = " <<
     (NOP+1)+NINT*NSTAGES*(NOP+1)+(NSTAGES-1)*(NOP+1)+s+1 << ";" << endl;
     nnzJacG++;
                  }
          }
  */

  evalg << "   //set index for nontrivial inequalities" << endl;
  for (int i = 0; i < nnop; ++i) {
    for (int s = 0; s < nop; ++s) {
      evalg << "      iRow[" << nnzJacG << "] = " << offset + i << "; jCol["
            << nnzJacG << "] = " << s + 1 << ";" << endl;
      nnzJacG++;
    }
  }
  offset += nnop;
  for (int k = 0; k <= NINT; ++k) {
    for (int s = 0; s < NSTAGES; ++s) {
      for (int i = 0; i < nnop; ++i) {
        for (int m = 0; m < nop; ++m) {
          evalg << "      iRow[" << nnzJacG << "] = " << offset << "; jCol["
                << nnzJacG << "] = "
                << (NOP + 1) + k * NSTAGES * (NOP + 1) + s * (NOP + 1) + m + 1
                << ";" << endl;
          nnzJacG++;
        }
        offset++;
      }
    }
  }

  evalg << "   // retruns entries in jacobian" << endl;
  evalg << "   } else {" << endl;

  // rename variables
  evalg << endl
        << "   //set variables and molar weights - coding NAME_INTERVAL_STAGE"
        << endl;
  evalg << "   Number Ms[" << nspec << "] = { " << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;
  evalg << "   Number Y_0_0[" << nop << "] = { x[0]";
  for (int i = 1; i < nop; ++i) {
    evalg << ",  x[" << i << "]";
  }
  evalg << "}, T_0_0 = x[" << nop << "];" << endl;

  for (int k = 0; k <= NINT; ++k) {
    for (int s = 1; s <= NSTAGES; ++s) {
      evalg << "   Number Y_" << k << "_" << s << "[" << nop << "] = { x["
            << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + 1 << "]";
      for (int i = 1; i < nop; ++i) {
        evalg << ", x["
              << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + i + 1
              << "]";
      }
      evalg << "}, T_" << k << "_" << s << " = x["
            << nop + k * NSTAGES * (nop + 1) + (s - 1) * (nop + 1) + nop + 1
            << "];" << endl;
    }
  }
  evalg << endl;

  // get required derivatives
  evalg << "   // get required derivatives" << endl;
  evalg << "   Number f_0_0[" << nop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", f_" << k << "_" << i << "[" << nop << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number H_0_0[" << nspec << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", H_" << k << "_" << i << "[" << nspec << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number Yres_0_0[" << nnop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", Yres_" << k << "_" << i << "[" << nnop << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number dTf_0_0[" << nop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", dTf_" << k << "_" << i << "[" << nop << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number dTH_0_0[" << nspec << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", dTH_" << k << "_" << i << "[" << nspec << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number dYf_0_0[" << nop << "][" << nop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", dYf_" << k << "_" << i << "[" << nop << "][" << nop << "]";
    }
  }
  evalg << ";" << endl;
  evalg << "   Number dYYres_0_0[" << nnop << "][" << nop << "]";
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << ", dYYres_" << k << "_" << i << "[" << nnop << "][" << nop
            << "]";
    }
  }
  evalg << ";" << endl;
  evalg << endl;

  evalg << "   //get first derivatives" << endl;
  evalg << "   getFirstDerivative_f(T_0_0, Y_0_0, f_0_0, dYf_0_0, dTf_0_0, "
           "H_0_0, dTH_0_0, Yres_0_0, dYYres_0_0);"
        << endl;
  for (int k = 0; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << "   getFirstDerivative_f(T_" << k << "_" << i << ", Y_" << k
            << "_" << i << ", f_" << k << "_" << i << ", dYf_" << k << "_" << i
            << ", dTf_" << k << "_" << i << ", H_" << k << "_" << i << ", dTH_"
            << k << "_" << i << ", Yres_" << k << "_" << i << ", dYYres_" << k
            << "_" << i << ");" << endl;
    }
  }
  evalg << endl;

  // generating constraint Jacobian values
  nnzJacG = 0;
  evalg << setprecision(15);
  for (int i = 1; i <= NSTAGES; ++i) {
    evalg << endl;
    evalg << "   // set derivatives of (interval,stage) = (0," << i << ")"
          << endl;
    for (int s = 0; s < nop; ++s) {
      evalg << "   values[" << nnzJacG << "] = -1.0;" << endl;
      nnzJacG++;
      for (int j = 1; j <= NSTAGES; ++j) {
        for (int m = 0; m < nop; ++m) {
          if ((s == m) && (i == j)) {
            evalg << "   values[" << nnzJacG << "] = 1.0-h*(" << A[i - 1][j - 1]
                  << ")*dYf_0_" << j << "[" << s << "][" << m << "];" << endl;
            nnzJacG++;
          } else {
            evalg << "   values[" << nnzJacG << "] = -h*(" << A[i - 1][j - 1]
                  << ")*dYf_0_" << j << "[" << s << "][" << m << "];" << endl;
            nnzJacG++;
          }
        }
        evalg << "   values[" << nnzJacG << "] = -h*(" << A[i - 1][j - 1]
              << ")*dTf_0_" << j << "[" << s << "];" << endl;
        nnzJacG++;
      }
    }
  }
  evalg << endl;

  // set derivatives of enthalply conservation for each stages
  evalg << "   // set derivatives of enthalpy conservation" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   values[" << nnzJacG << "] = H_0_0[" << Iop[s] - 1 << "]/Ms["
          << Iop[s] - 1 << "]";
    for (int m = 0; m < nnop; ++m) {
      evalg << " + H_0_0[" << Inop[m] - 1 << "]/Ms[" << Inop[m] - 1
            << "] * dYYres_0_0[" << m << "][" << s << "]";
    }
    evalg << ";" << endl;
    nnzJacG++;
  }
  evalg << "   values[" << nnzJacG << "] = 0.0";
  for (int s = 0; s < nop; ++s) {
    evalg << " + dTH_0_0[" << Iop[s] - 1 << "] * Y_0_0[" << s << "]/Ms["
          << Iop[s] - 1 << "]";
  }
  for (int s = 0; s < nnop; ++s) {
    evalg << " + dTH_0_0[" << Inop[s] - 1 << "] * Yres_0_0[" << s << "]/Ms["
          << Inop[s] - 1 << "]";
  }
  evalg << ";" << endl;
  nnzJacG++;

  for (int i = 1; i <= NSTAGES; ++i) {
    evalg << endl;
    for (int s = 0; s < nop; ++s) {
      evalg << "   values[" << nnzJacG << "] = H_0_" << i << "[" << Iop[s] - 1
            << "]/Ms[" << Iop[s] - 1 << "]";
      for (int m = 0; m < nnop; ++m) {
        evalg << " + H_0_" << i << "[" << Inop[m] - 1 << "]/Ms[" << Inop[m] - 1
              << "] * dYYres_0_" << i << "[" << m << "][" << s << "]";
      }
      evalg << ";" << endl;
      nnzJacG++;
    }
    evalg << "   values[" << nnzJacG << "] = 0.0";
    for (int s = 0; s < nop; ++s) {
      evalg << " + dTH_0_" << i << "[" << Iop[s] - 1 << "] * Y_0_" << i << "["
            << s << "]/Ms[" << Iop[s] - 1 << "]";
    }
    for (int s = 0; s < nnop; ++s) {
      evalg << " + dTH_0_" << i << "[" << Inop[s] - 1 << "] * Yres_0_" << i
            << "[" << s << "]/Ms[" << Inop[s] - 1 << "]";
    }
    evalg << ";" << endl;
    nnzJacG++;
  }

  for (int k = 1; k <= NINT; ++k) {
    for (int i = 1; i <= NSTAGES; ++i) {
      evalg << endl;
      evalg << "   // set derivatives of (interval,stage) = (" << k << "," << i
            << ")" << endl;
      for (int s = 0; s < nop; ++s) {
        evalg << "   values[" << nnzJacG << "] = -1.0;" << endl;
        nnzJacG++;
        for (int j = 1; j <= NSTAGES; ++j) {
          for (int m = 0; m < nop; ++m) {
            if ((s == m) && (i == j)) {
              evalg << "   values[" << nnzJacG << "] = 1.0-h*("
                    << A[i - 1][j - 1] << ")*dYf_" << k << "_" << j << "[" << s
                    << "][" << m << "];" << endl;
              nnzJacG++;
            } else {
              evalg << "   values[" << nnzJacG << "] = -h*(" << A[i - 1][j - 1]
                    << ")*dYf_" << k << "_" << j << "[" << s << "][" << m
                    << "];" << endl;
              nnzJacG++;
            }
          }
          evalg << "   values[" << nnzJacG << "] = -h*(" << A[i - 1][j - 1]
                << ")*dTf_" << k << "_" << j << "[" << s << "];" << endl;
          nnzJacG++;
        }
      }
    }
    evalg << endl;

    // set derivatives of enthalply conservation for each stages
    evalg << "   // set derivatives of enthalpy conservation" << endl;
    for (int i = 1; i <= NSTAGES; ++i) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   values[" << nnzJacG << "] = H_" << k << "_" << i << "["
              << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1 << "]";
        for (int m = 0; m < nnop; ++m) {
          evalg << " + H_" << k << "_" << i << "[" << Inop[m] - 1 << "]/Ms["
                << Inop[m] - 1 << "] * dYYres_" << k << "_" << i << "[" << m
                << "][" << s << "]";
        }
        evalg << ";" << endl;
        nnzJacG++;
      }
      evalg << "   values[" << nnzJacG << "] = 0.0";
      for (int s = 0; s < nop; ++s) {
        evalg << " + dTH_" << k << "_" << i << "[" << Iop[s] - 1 << "] * Y_"
              << k << "_" << i << "[" << s << "]/Ms[" << Iop[s] - 1 << "]";
      }
      for (int s = 0; s < nnop; ++s) {
        evalg << " + dTH_" << k << "_" << i << "[" << Inop[s] - 1 << "] * Yres_"
              << k << "_" << i << "[" << s << "]/Ms[" << Inop[s] - 1 << "]";
      }
      evalg << ";" << endl;
      nnzJacG++;
    }
  }

  // if there is no resolution
  if (NNOP == 0) {
    evalg << "   // set derivatives of mass conservation" << endl;
    for (int a = 1; a <= natom; ++a) {
      for (int s = 1; s <= nspec; ++s) {
        evalg << "   values[" << nnzJacG << "] = " << std::setprecision(15)
              << consMatrix[a - 1][s - 1] << ";" << endl;
        nnzJacG++;
      }
    }
  }

  // set derivatvie of the fixiation of the rpv
  for (int i = 0; i < NRPV; ++i) {
    evalg << "   values[" << nnzJacG << "] = 1.0;" << endl;
    nnzJacG++;
  }

  // set nontrivial inequalities
  if (NNOP > 0) {
    evalg << "   //set inequalities. Note: dYYres = const. so we only use "
             "dYYres_0_0"
          << endl;
    for (int k = 0; k < (NSTAGES * (NINT + 1) + 1); ++k) {
      for (int m = 0; m < nnop; ++m) {
        for (int i = 0; i < nop; ++i) {
          evalg << "   values[" << nnzJacG << "] = dYYres_0_0[" << m << "]["
                << i << "];" << endl;
          nnzJacG++;
        }
      }
    }
  }

  // close function and file
  evalg << "   }" << endl;
  evalg << endl << "   return true;" << endl;
  evalg << endl << "}";

  evalg.close();
}

void generateAuxiliary(vector<string> species, vector<vector<int>> nuprime,
                       vector<vector<int>> nu2prime,
                       vector<vector<double>> consMatrix, vector<double> Ms,
                       vector<int> bodyPos, vector<int> bodyNumber,
                       vector<vector<double>> bodyCoeff, string filename) {

  // get problem dimensions
  int nop = NOP;
  int nnop = NNOP;
  int ntb = NTB;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;
  int nspec = species.size();
  int nreac = nuprime[0].size();

  int nu[nspec][nreac];
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < nreac; ++k) {
      nu[i][k] = nu2prime[i][k] - nuprime[i][k];
    }
  }

  // get time for time stamp
  time_t t;
  time(&t);

  ofstream evalg("auxiliaries.hpp");
  evalg << "/* Autogenerated file on " << ctime(&t);
  evalg << " *    Function defining some useful auxilary functions" << endl;
  evalg << " *    Mechanism: " << filename << endl;
  evalg << " */" << endl << endl;

  evalg << "void ammsockNLP::get_f(const Number T, const Number Y[" << nop
        << "], Number f[" << nop << "]) {" << endl
        << endl;
  // prepare preliminares
  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, Mbar;" << endl;
  evalg << "   Number q[" << nreac << "], qtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "];" << endl;
  evalg << "   Number M[" << bodyCoeff.size() << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], Gm[" << nreac << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], Rm[" << nreac << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << "   Number H[" << nspec << "], dTH[" << nspec << "], dTTH[" << nspec
        << "];" << endl;
  evalg << endl;
  evalg << "   //call overloaded function" << endl;
  evalg << "   "
           "get_f(T,Y,f,rho,Mbar,q,qtilde,omega,M,Gp,Gm,Rp,Rm,kf,dTkf,dTTkf,kr,"
           "dTkr,dTTkr,H,dTH,dTTH);"
        << endl;

  evalg << endl;
  evalg << "}" << endl;

  evalg << endl;

  evalg << "void ammsockNLP::get_f(const Number T, const Number _Y[" << nop
        << "], Number f[" << nop << "], Number H[" << nspec << "], Number Yres["
        << nnop << "]) {" << endl
        << endl;

  // prepare preliminares
  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, Mbar;" << endl;
  evalg << "   Number q[" << nreac << "], qtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "];" << endl;
  evalg << "   Number M[" << bodyCoeff.size() << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], Gm[" << nreac << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], Rm[" << nreac << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << "   Number dTH[" << nspec << "], dTTH[" << nspec << "];" << endl;
  evalg << endl;
  evalg << "   //set resolved species" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Yres[" << i << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << endl;
  evalg << "   //call overloaded function" << endl;
  evalg << "   "
           "get_f(T,_Y,f,rho,Mbar,q,qtilde,omega,M,Gp,Gm,Rp,Rm,kf,dTkf,dTTkf,"
           "kr,dTkr,dTTkr,H,dTH,dTTH);"
        << endl;

  evalg << endl;
  evalg << "}" << endl;

  evalg << endl;

  evalg << "void ammsockNLP::get_f(const Number T, const Number _Y[" << nop
        << "], Number f[" << nop << "], Number &rho, Number &Mbar, Number q["
        << nreac << "], Number qtilde[" << nreac << "], Number omega[" << nop
        << "], Number M[" << ntb << "],  Number Gp[" << nreac << "], Number Gm["
        << nreac << "],Number Rp[" << nreac << "], Number Rm[" << nreac
        << "], Number kf[" << nreac << "], Number dTkf[" << nreac
        << "], Number dTTkf[" << nreac << "], Number kr[" << nreac
        << "], Number dTkr[" << nreac << "], Number dTTkr[" << nreac
        << "], Number H[" << nspec << "], Number dTH[" << nspec
        << "], Number dTTH[" << nspec << "]) {" << endl
        << endl;

  // prepare preliminares
  evalg << "   // Preliminaries" << endl;
  evalg << "   Number Y[" << nspec << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   Y[" << Iop[i] - 1 << "] = _Y[" << i << "];" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Y[" << Inop[i] - 1 << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << "   Number Ms[" << nspec << "] = { " << std::setprecision(15)
        << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;
  evalg << "   Number p = 101325; // fixed pressure in an isobaric case"
        << endl;
  evalg << "   Number R = 8.3144598;" << endl << endl;

  evalg << "   //calculate Mbar and density rho" << endl;
  evalg << "   Mbar = 1.0/( 0.0";
  for (int i = 0; i < nspec; ++i) {
    evalg << " + Y[" << i << "]/Ms[" << i << "] ";
  }
  evalg << ");" << endl;
  evalg << "   rho = p*Mbar/(R*T);" << endl;

  // calculate rates
  evalg << endl << "   // Calculate rates" << endl;
  evalg << "   rates(T,kf,kr,dTkf,dTkr,dTTkf,dTTkr,H,dTH,dTTH);" << endl;

  // generating third bodies
  evalg << endl << "   // Generate third bodies" << endl;
  for (int i = 0; i < bodyCoeff.size(); ++i) {
    evalg << "   M[" << i << "] = 0.0";
    for (int k = 0; k < nspec; ++k) {
      evalg << " + " << bodyCoeff[i][k] << " * rho*Y[" << k << "]/Ms[" << k
            << "]";
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  evalg << "   // general terms and rest terms" << endl;
  for (int r = 0; r < nreac; ++r) {
    evalg << "   Gp[" << r << "] = 1.0";
    for (int k = 0; k < nop; ++k) {
      if (nuprime[Iop[k] - 1][r] != 0) {
        for (int i = 1; i <= nuprime[Iop[k] - 1][r]; ++i) {
          evalg << "* Y[" << Iop[k] - 1 << "]/Ms[" << Iop[k] - 1 << "]";
        }
      }
    }
    evalg << ";" << endl;
  }
  for (int r = 0; r < nreac; ++r) {
    evalg << "   Gm[" << r << "] = 1.0";
    for (int k = 0; k < nop; ++k) {
      if (nu2prime[Iop[k] - 1][r] != 0) {
        for (int i = 1; i <= nu2prime[Iop[k] - 1][r]; ++i) {
          evalg << "* Y[" << Iop[k] - 1 << "]/Ms[" << Iop[k] - 1 << "]";
        }
      }
    }
    evalg << ";" << endl;
  }
  for (int r = 0; r < nreac; ++r) {
    evalg << "   Rp[" << r << "] = 1.0";
    for (int k = 0; k < nnop; ++k) {
      if (nuprime[Inop[k] - 1][r] != 0) {
        for (int i = 1; i <= nuprime[Inop[k] - 1][r]; ++i) {
          evalg << "* Y[" << Inop[k] - 1 << "]/Ms[" << Inop[k] - 1 << "]";
        }
      }
    }
    evalg << ";" << endl;
  }
  for (int r = 0; r < nreac; ++r) {
    evalg << "   Rm[" << r << "] = 1.0";
    for (int k = 0; k < nnop; ++k) {
      if (nu2prime[Inop[k] - 1][r] != 0) {
        for (int i = 1; i <= nu2prime[Inop[k] - 1][r]; ++i) {
          evalg << "* Y[" << Inop[k] - 1 << "]/Ms[" << Inop[k] - 1 << "]";
        }
      }
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  // generate qtilde
  evalg << "   // Generate qtilde for each reaction" << endl;
  for (int i = 0; i < nreac; ++i) {
    // get nubarprime, nubar2prime
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }
    evalg << "   qtilde[" << i << "] = "
          << "kf[" << i << "] * pow(rho," << nubarprime << ") * Gp[" << i
          << "] * Rp[" << i << "] - kr[" << i << "] * pow(rho," << nubar2prime
          << ") * Gm[" << i << "] * Rm[" << i << "];" << endl;
  }
  evalg << endl;

  // generate q
  evalg << "   // Generate q" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);
    // if there isn't a third body
    if (ind == -1) {
      evalg << "   q[" << i << "] = qtilde[" << i << "];" << endl;
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      evalg << "   q[" << i << "] = M[" << whichThirdBody << "] * qtilde[" << i
            << "];" << endl;
    }
  }
  evalg << endl;

  // generating omega
  evalg << "   // Generate omega" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   omega[" << s << "] = 0.0 ";
    for (int r = 0; r < nreac; ++r) {
      if (nu[Iop[s] - 1][r] != 0)
        evalg << "+ (" << nu[Iop[s] - 1][r] << ") * "
              << "q[" << r << "] ";
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  // generating dotY
  evalg << "   // Generate f" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   f[" << s << "] = Ms[" << Iop[s] - 1 << "]/rho * omega[" << s
          << "];" << endl;
  }
  evalg << "}" << endl << endl;

  evalg
      << "void ammsockNLP::getFirstDerivative_f(const Number T, const Number Y["
      << nop << "], Number f[" << nop << "], Number dYf[" << nop << "][" << nop
      << "], Number dTf[" << nop << "], Number H[" << nspec << "], Number dTH["
      << nspec << "]) {" << endl
      << endl;
  evalg << "   // Preliminaries" << endl;
  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, dYrho[" << nop << "], dTrho, Mbar, dYMbar[" << nop
        << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << "   Number dTTH[" << nreac << "];" << endl;

  evalg << endl;

  evalg << "   //call overloaded function" << endl;
  evalg
      << "   "
         "getFirstDerivative_f(T,Y,f,dYf,dTf,rho,dYrho,dTrho,Mbar,dYMbar,q,dYq,"
         "dTq,qtilde,dYqtilde,dTqtilde,omega,dYomega,dTomega,M,dYM,dTM,Gp,dYGp,"
         "Gm,dYGm,Rp,dYRp,Rm,dYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
      << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getFirstDerivative_f(const Number T, const Number "
           "_Y["
        << nop << "], Number f[" << nop << "], Number dYf[" << nop << "]["
        << nop << "], Number dTf[" << nop << "], Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number Yres[" << nnop
        << "], Number dYYres[" << nnop << "][" << nop << "]) {" << endl
        << endl;
  evalg << "   // Preliminaries" << endl;
  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, dYrho[" << nop << "], dTrho, Mbar, dYMbar[" << nop
        << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << "   Number dTTH[" << nreac << "];" << endl;
  evalg << endl;

  evalg << "   //set resolved species and their derivatives" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Yres[" << i << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << i << "[" << nop << "] =  DIFFY" << Inop[i] - 1
          << "RES;" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    for (int j = 0; j < nop; ++j) {
      evalg << "   dYYres[" << i << "][" << j << "] = dYY" << i << "[" << j
            << "];" << endl;
    }
  }
  evalg << endl;

  evalg << "   //call overloaded function" << endl;
  evalg
      << "   "
         "getFirstDerivative_f(T,_Y,f,dYf,dTf,rho,dYrho,dTrho,Mbar,dYMbar,q,"
         "dYq,dTq,qtilde,dYqtilde,dTqtilde,omega,dYomega,dTomega,M,dYM,dTM,Gp,"
         "dYGp,Gm,dYGm,Rp,dYRp,Rm,dYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
      << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getFirstDerivative_f(const Number T, const Number "
           "_Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "]," << endl;
  evalg << "					Number &rho, Number dYrho["
        << nop << "], Number &dTrho," << endl;
  evalg << "					Number &Mbar, Number dYMbar["
        << nop << "]," << endl;
  evalg << "					Number q[" << nreac
        << "], Number dYq[" << nreac << "][" << nop << "], Number dTq[" << nreac
        << "]," << endl;
  evalg << "					Number qtilde[" << nreac
        << "], Number dYqtilde[" << nreac << "][" << nop
        << "], Number dTqtilde[" << nreac << "]," << endl;
  evalg << "					Number omega[" << nop
        << "], Number dYomega[" << nop << "][" << nop << "], Number dTomega["
        << nop << "]," << endl;
  evalg << "					Number M[" << ntb
        << "], Number dYM[" << ntb << "][" << nop << "], Number dTM[" << ntb
        << "]," << endl;
  evalg << "					Number Gp[" << nreac
        << "], Number dYGp[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number Gm[" << nreac
        << "], Number dYGm[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number Rp[" << nreac
        << "], Number dYRp[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number Rm[" << nreac
        << "], Number dYRm[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number kf[" << nreac
        << "], Number dTkf[" << nreac << "], Number dTTkf[" << nreac << "],"
        << endl;
  evalg << "					Number kr[" << nreac
        << "], Number dTkr[" << nreac << "], Number dTTkr[" << nreac << "],"
        << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec << "]) {"
        << endl
        << endl;
  evalg << "   // Preliminaries" << endl;
  evalg << "   Number Y[" << nspec << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   Y[" << Iop[i] - 1 << "] = _Y[" << i << "];" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Y[" << Inop[i] - 1 << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }

  evalg << "   Number Ms[" << nspec << "] = { " << std::setprecision(15)
        << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;

  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << Inop[i] - 1 << "[" << nop << "] =  DIFFY"
          << Inop[i] - 1 << "RES;" << endl;
  }

  evalg << "   //call function get_f" << endl;
  evalg << "   "
           "get_f(T,_Y,f,rho,Mbar,q,qtilde,omega,M,Gp,Gm,Rp,Rm,kf,dTkf,dTTkf,"
           "kr,dTkr,dTTkr,H,dTH,dTTH);"
        << endl;

  evalg << "   // density" << endl;
  evalg << "   dTrho = -rho/T;" << endl;
  evalg << "   // Generate dYrho" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dYrho[" << s << "] = -Mbar*rho*(1/Ms[" << Iop[s] - 1 << "] ";
    for (int i = 0; i < nnop; ++i) {
      evalg << " + 1/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << s
            << "]";
    }
    evalg << ");" << endl;
  }
  evalg << endl;

  evalg << "   // Generate dYMbar" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dYMbar[" << s << "] = -Mbar*Mbar*(1/Ms[" << Iop[s] - 1 << "] ";
    for (int i = 0; i < nnop; ++i) {
      evalg << " + 1/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << s
            << "]";
    }
    evalg << ");" << endl;
  }
  evalg << endl;

  evalg << "   // third body" << endl;
  evalg << "   Number sumAlphaYM = 0.0;	" << endl;

  // generating third bodies and their derivatives
  for (int k = 0; k < bodyCoeff.size(); ++k) {
    evalg << "   //generate third body #" << k + 1 << endl;
    evalg << "   sumAlphaYM = 0.0 ";
    for (int s = 0; s < nspec; ++s) {
      evalg << " + " << bodyCoeff[k][s] << " * Y[" << s << "]/Ms[" << s << "]";
    }
    evalg << ";" << endl;
    evalg << "   // Generate dTM" << endl;
    evalg << "   dTM[" << k << "] = -M[" << k << "]/T;" << endl;
    evalg << "   // Generate dYM" << endl;
    for (int s = 0; s < nop; ++s) {
      evalg << "   dYM[" << k << "][" << s << "] = dYrho[" << s
            << "]*sumAlphaYM + rho*(" << bodyCoeff[k][Iop[s] - 1] << "/Ms["
            << Iop[s] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms[" << Inop[i] - 1
              << "] * dYY" << Inop[i] - 1 << "[" << s << "]";
      }
      evalg << ");" << endl;
    }
    evalg << endl;
  }
  evalg << "   // derivatives of general terms" << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYGp[" << r << "][" << m << "] = 0.0";
      if (nuprime[Iop[m] - 1][r] != 0) {
        evalg << " + (" << nuprime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
              << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1 << "],"
              << nuprime[Iop[m] - 1][r] - 1 << ")";
        for (int i = 0; i < nop; ++i) {
          if (i != m) {
            for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
              evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1 << "]";
            }
          }
        }
      }
      evalg << ";" << endl;
    }
  }
  evalg << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYGm[" << r << "][" << m << "] = 0.0";
      if (nu2prime[Iop[m] - 1][r] != 0) {
        evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
              << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1 << "],"
              << nu2prime[Iop[m] - 1][r] - 1 << ")";
        for (int i = 0; i < nop; ++i) {
          if (i != m) {
            for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
              evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1 << "]";
            }
          }
        }
      }
      evalg << ";" << endl;
    }
  }
  evalg << endl;

  evalg << "   // derivatives of rest terms" << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYRp[" << r << "][" << m << "] = 0.0";
      for (int i = 0; i < nnop; ++i) {
        if (nuprime[Inop[i] - 1][r] != 0) {
          evalg << " + (" << nuprime[Inop[i] - 1][r] << ")/Ms[" << Inop[i] - 1
                << "] * pow(Y[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1 << "],"
                << nuprime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                << "[" << m << "]";
          for (int j = 0; j < nnop; ++j) {
            if ((nuprime[Inop[j] - 1][r]) && (j != i)) {
              evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms[" << Inop[j] - 1
                    << "]," << nuprime[Inop[j] - 1][r] << ")";
            }
          }
        }
      }
      evalg << ";" << endl;
    }
  }
  evalg << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYRm[" << r << "][" << m << "] = 0.0";
      for (int i = 0; i < nnop; ++i) {
        if (nu2prime[Inop[i] - 1][r] != 0) {
          evalg << " + (" << nu2prime[Inop[i] - 1][r] << ")/Ms[" << Inop[i] - 1
                << "] * pow(Y[" << Inop[i] - 1 << "]/Ms[" << Inop[i] - 1 << "],"
                << nu2prime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                << "[" << m << "]";
          for (int j = 0; j < nnop; ++j) {
            if ((nu2prime[Inop[j] - 1][r]) && (j != i)) {
              evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms[" << Inop[j] - 1
                    << "]," << nu2prime[Inop[j] - 1][r] << ")";
            }
          }
        }
      }
      evalg << ";" << endl;
    }
  }
  evalg << endl;

  // generating dTqtilde
  evalg << endl << "   // Generate dTqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    // get nubarprime, nubar2prime
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }
    evalg << "   dTqtilde[" << i << "] = ( dTkf[" << i << "] - kf[" << i
          << "]*(" << nubarprime << ")/T )  * pow(rho," << nubarprime
          << ") * Gp[" << i << "] * Rp[" << i << "] - ( dTkr[" << i << "] - kr["
          << i << "]*(" << nubar2prime << ")/T )  * pow(rho," << nubar2prime
          << ") * Gm[" << i << "] * Rm[" << i << "];" << endl;
  }

  // generating dYqtilde
  evalg << endl << "   // Generate dYqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    // get nubarprime, nubar2prime
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }
    for (int s = 0; s < nop; ++s) {
      evalg << "   dYqtilde[" << i << "][" << s << "] = kf[" << i << "] * ( (("
            << nubarprime << ")*pow(rho," << nubarprime - 1 << ") * dYrho[" << s
            << "] * Gp[" << i << "] + pow(rho," << nubarprime << ") * dYGp["
            << i << "][" << s << "]) * Rp[" << i << "] + pow(rho," << nubarprime
            << ") * Gp[" << i << "] * dYRp[" << i << "][" << s << "])";
      evalg << " - kr[" << i << "] * ( ((" << nubar2prime << ")*pow(rho,"
            << nubar2prime - 1 << ") * dYrho[" << s << "] * Gm[" << i
            << "] + pow(rho," << nubar2prime << ") * dYGm[" << i << "][" << s
            << "]) * Rm[" << i << "] + pow(rho," << nubar2prime << ") * Gm["
            << i << "] * dYRm[" << i << "][" << s << "])";
      evalg << ";" << endl;
    }
    evalg << endl;
  }

  // generating dYq
  evalg << endl << "   // Generate dYq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);
    // if there isn't a third body
    if (ind == -1) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYq[" << i << "][" << s << "] = dYqtilde[" << i << "]["
              << s << "];" << endl;
      }
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYq[" << i << "][" << s << "] = M[" << whichThirdBody
              << "] * dYqtilde[" << i << "][" << s << "] + dYM["
              << whichThirdBody << "][" << s << "] * qtilde[" << i << "];"
              << endl;
      }
    }
    evalg << endl;
  }

  // generating dTq
  evalg << endl << "   // Generate dTq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);
    // if there isn't a third body
    if (ind == -1) {
      evalg << "   dTq[" << i << "] = dTqtilde[" << i << "];" << endl;
      // otherwise insert third body
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      evalg << "   dTq[" << i << "] = M[" << whichThirdBody << "] * dTqtilde["
            << i << "] + dTM[" << whichThirdBody << "]* qtilde[" << i << "];"
            << endl;
    }
  }
  evalg << endl << endl;

  // generating dYomega
  evalg << endl << "   // Generate dYomega" << endl;
  for (int s = 0; s < nop; ++s) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYomega[" << s << "][" << m << "] = 0.0";
      for (int r = 0; r < nreac; ++r) {
        if (nu[Iop[s] - 1][r] != 0)
          evalg << " + (" << nu[Iop[s] - 1][r] << ") * dYq[" << r << "][" << m
                << "]";
      }
      evalg << ";" << endl;
    }
    evalg << endl;
  }

  // generating dTomega
  evalg << endl << "   // Generate dTomega" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dTomega[" << s << "] = 0.0";
    for (int r = 0; r < nreac; ++r) {
      if (nu[Iop[s] - 1][r] != 0)
        evalg << " + (" << nu[Iop[s] - 1][r] << ") * dTq[" << r << "]";
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  // generating dYf
  evalg << endl << "   // Generate dYf" << endl;
  for (int s = 0; s < nop; ++s) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYf[" << s << "][" << m << "] = Ms[" << Iop[s] - 1
            << "] * (1.0/rho*dYomega[" << s << "][" << m << "] - omega[" << s
            << "]/(rho*rho)*dYrho[" << m << "]);" << endl;
    }
    evalg << endl;
  }

  // generating dTf
  evalg << "   // Generate dTf" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dTf[" << s << "] = Ms[" << Iop[s] - 1
          << "] * (1.0/rho*dTomega[" << s << "] + omega[" << s << "]/(rho*T));"
          << endl;
  }
  evalg << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  /*****************
   *   getSecondDerivative_f
   *****************/
  evalg << "void ammsockNLP::getSecondDerivative_f(const Number T, const "
           "Number Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec << "]) {"
        << endl
        << endl;

  evalg << "   //allocate memory" << endl;
  evalg << "   Number dTTf[" << nop << "];" << endl;
  evalg << "   Number rho, dYrho[" << nop << "], dTrho, dYYrho[" << nop << "]["
        << nop << "], dYTrho[" << nop << "], dTTrho;" << endl;
  evalg << "   Number Mbar, dYMbar[" << nop << "], dYYMbar[" << nop << "]["
        << nop << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "],  dYYq[" << nreac << "][" << nop << "]["
        << nop << "], dYTq[" << nreac << "][" << nop << "], dTTq[" << nreac
        << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "], dYYqtilde[" << nreac << "]["
        << nop << "][" << nop << "], dYTqtilde[" << nreac << "][" << nop
        << "], dTTqtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "], dYYomega[" << nop << "][" << nop << "]["
        << nop << "], dYTomega[" << nop << "][" << nop << "], dTTomega[" << nop
        << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "], dYYM[" << ntb << "][" << nop << "][" << nop << "], dYTM["
        << ntb << "][" << nop << "], dTTM[" << ntb << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "], dYYGp[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "], dYYGm[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "], dYYRp[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "], dYYRm[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;
  evalg << endl;

  evalg << "   //call overloaded function" << endl;
  evalg << "   "
           "getSecondDerivative_f(T,Y,f,dYf,dTf,dYYf,dYTf,dTTf,rho,dYrho,dTrho,"
           "dYYrho,dYTrho,dTTrho,Mbar,dYMbar,dYYMbar,q,dYq,dTq,dYYq,dYTq,dTTq,"
           "qtilde,dYqtilde,dTqtilde,dYYqtilde,dYTqtilde,dTTqtilde,omega,"
           "dYomega,dTomega,dYYomega,dYTomega,dTTomega,M,dYM,dTM,dYYM,dYTM,"
           "dTTM,Gp,dYGp,dYYGp,Gm,dYGm,dYYGm,Rp,dYRp,dYYRp,Rm,dYRm,dYYRm,kf,"
           "dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
        << endl;
  evalg << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getSecondDerivative_f(const Number T, const "
           "Number _Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "], Number dTTf[" << nop
        << "]," << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec
        << "],  Number Yres[" << nnop << "], Number dYYres[" << nnop << "]["
        << nop << "]) {" << endl
        << endl;

  evalg << "   //allocate memory" << endl;
  evalg << "   Number rho, dYrho[" << nop << "], dTrho, dYYrho[" << nop << "]["
        << nop << "], dYTrho[" << nop << "], dTTrho;" << endl;
  evalg << "   Number Mbar, dYMbar[" << nop << "], dYYMbar[" << nop << "]["
        << nop << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "],  dYYq[" << nreac << "][" << nop << "]["
        << nop << "], dYTq[" << nreac << "][" << nop << "], dTTq[" << nreac
        << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "], dYYqtilde[" << nreac << "]["
        << nop << "][" << nop << "], dYTqtilde[" << nreac << "][" << nop
        << "], dTTqtilde[" << nreac << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "], dYYomega[" << nop << "][" << nop << "]["
        << nop << "], dYTomega[" << nop << "][" << nop << "], dTTomega[" << nop
        << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "], dYYM[" << ntb << "][" << nop << "][" << nop << "], dYTM["
        << ntb << "][" << nop << "], dTTM[" << ntb << "];" << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "], dYYGp[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "], dYYGm[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "], dYYRp[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "], dYYRm[" << nreac << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;

  evalg << "   //set resolved species and their derivatives" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Yres[" << i << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << endl;
  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << i << "[" << nop << "] =  DIFFY" << Inop[i] - 1
          << "RES;" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    for (int j = 0; j < nop; ++j) {
      evalg << "   dYYres[" << i << "][" << j << "] = dYY" << i << "[" << j
            << "];" << endl;
    }
  }
  evalg << endl;

  evalg << "   //call overloaded function" << endl;
  evalg << "   "
           "getSecondDerivative_f(T,_Y,f,dYf,dTf,dYYf,dYTf,dTTf,rho,dYrho,"
           "dTrho,dYYrho,dYTrho,dTTrho,Mbar,dYMbar,dYYMbar,q,dYq,dTq,dYYq,dYTq,"
           "dTTq,qtilde,dYqtilde,dTqtilde,dYYqtilde,dYTqtilde,dTTqtilde,omega,"
           "dYomega,dTomega,dYYomega,dYTomega,dTTomega,M,dYM,dTM,dYYM,dYTM,"
           "dTTM,Gp,dYGp,dYYGp,Gm,dYGm,dYYGm,Rp,dYRp,dYYRp,Rm,dYRm,dYYRm,kf,"
           "dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
        << endl;
  evalg << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getSecondDerivative_f(const Number T, const "
           "Number _Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "], Number dTTf[" << nop
        << "]," << endl;
  evalg << "					Number &rho, Number dYrho["
        << nop << "], Number &dTrho, Number dYYrho[" << nop << "][" << nop
        << "], Number dYTrho[" << nop << "], Number &dTTrho," << endl;
  evalg << "					Number &Mbar, Number dYMbar["
        << nop << "], Number dYYMbar[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number q[" << nreac
        << "], Number dYq[" << nreac << "][" << nop << "], Number dTq[" << nreac
        << "],  Number dYYq[" << nreac << "][" << nop << "][" << nop
        << "], Number dYTq[" << nreac << "][" << nop << "], Number dTTq["
        << nreac << "]," << endl;
  evalg << "					Number qtilde[" << nreac
        << "], Number dYqtilde[" << nreac << "][" << nop
        << "], Number dTqtilde[" << nreac << "], Number dYYqtilde[" << nreac
        << "][" << nop << "][" << nop << "], Number dYTqtilde[" << nreac << "]["
        << nop << "], Number dTTqtilde[" << nreac << "]," << endl;
  evalg << "					Number omega[" << nop
        << "], Number dYomega[" << nop << "][" << nop << "], Number dTomega["
        << nop << "], Number dYYomega[" << nop << "][" << nop << "][" << nop
        << "], Number dYTomega[" << nop << "][" << nop << "], Number dTTomega["
        << nop << "]," << endl;
  evalg << "					Number M[" << ntb
        << "], Number dYM[" << ntb << "][" << nop << "], Number dTM[" << ntb
        << "], Number dYYM[" << ntb << "][" << nop << "][" << nop
        << "], Number dYTM[" << ntb << "][" << nop << "], Number dTTM[" << ntb
        << "]," << endl;
  evalg << "					Number Gp[" << nreac
        << "], Number dYGp[" << nreac << "][" << nop << "], Number dYYGp["
        << nreac << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Gm[" << nreac
        << "], Number dYGm[" << nreac << "][" << nop << "], Number dYYGm["
        << nreac << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Rp[" << nreac
        << "], Number dYRp[" << nreac << "][" << nop << "], Number dYYRp["
        << nreac << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Rm[" << nreac
        << "], Number dYRm[" << nreac << "][" << nop << "], Number dYYRm["
        << nreac << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number kf[" << nreac
        << "], Number dTkf[" << nreac << "], Number dTTkf[" << nreac << "],"
        << endl;
  evalg << "					Number kr[" << nreac
        << "], Number dTkr[" << nreac << "], Number dTTkr[" << nreac << "],"
        << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec << "]) {"
        << endl
        << endl;

  // get variables and molar weights
  evalg << "   // Preliminaries" << endl;
  evalg << "   Number Y[" << nspec << "];" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   Y[" << Iop[i] - 1 << "] = _Y[" << i << "];" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Y[" << Inop[i] - 1 << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }

  evalg << "   Number Ms[" << nspec << "] = { " << std::setprecision(15)
        << 1e-3 * Ms[0];
  for (int i = 1; i < Ms.size(); ++i) {
    evalg << ", " << 1e-3 * Ms[i];
  }
  evalg << "}; //molar weights in kg/mol" << endl;
  evalg << endl;

  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << Inop[i] - 1 << "[" << nop << "] =  DIFFY"
          << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << endl;

  // get first derivative
  evalg << "   //get first derivatives" << endl;
  evalg
      << "   "
         "getFirstDerivative_f(T,_Y,f,dYf,dTf,rho,dYrho,dTrho,Mbar,dYMbar,q,"
         "dYq,dTq,qtilde,dYqtilde,dTqtilde,omega,dYomega,dTomega,M,dYM,dTM,Gp,"
         "dYGp,Gm,dYGm,Rp,dYRp,Rm,dYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
      << endl;
  evalg << endl;

  // generating dYYrho
  evalg << "   // Generate dTTrho and dYYrho" << endl;
  evalg << "   dTTrho = 2*rho/(T*T);" << endl;
  for (int s = 0; s < nop; ++s) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYYrho[" << s << "][" << m << "] = -( dYMbar[" << m
            << "] * rho + Mbar * dYrho[" << m << "]) * (1.0/Ms[" << Iop[s] - 1
            << "]";
      for (int i = 0; i < nnop; ++i) {
        evalg << " + 1.0/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "["
              << s << "]";
      }
      evalg << ");" << endl;
    }
    evalg << endl;
  }

  // generating dYYrho
  evalg << "   // Generate dYYMbar" << endl;
  for (int s = 0; s < nop; ++s) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYYMbar[" << s << "][" << m
            << "] = 2*Mbar*Mbar*Mbar * (1.0/Ms[" << Iop[s] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalg << " + 1.0/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "["
              << s << "]";
      }
      evalg << ") * (1.0/Ms[" << Iop[m] - 1 << "]";
      for (int i = 0; i < nnop; ++i) {
        evalg << " + 1.0/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "["
              << m << "]";
      }
      evalg << ");" << endl;
    }
    evalg << endl;
  }

  // generating dYM and dYYM
  evalg << "   // Generate dTTM and dYYM" << endl;
  evalg << "   Number sumAlphaYM = 0.0;" << endl;
  for (int k = 0; k < bodyCoeff.size(); ++k) {
    evalg << "   // third body #" << k + 1 << endl;
    evalg << "   dTTM[" << k << "] = 2*M[" << k << "]/(T*T);" << endl;
    evalg << "   sumAlphaYM = 0.0 ";
    for (int s = 0; s < nspec; ++s) {
      evalg << " + " << bodyCoeff[k][s] << " * Y[" << s << "]/Ms[" << s << "]";
    }
    evalg << ";" << endl;
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYM[" << k << "][" << s << "][" << m << "] = dYYrho[" << s
              << "][" << m << "]*sumAlphaYM + dYrho[" << s << "]*("
              << bodyCoeff[k][Iop[m] - 1] << "/Ms[" << Iop[m] - 1 << "]";
        for (int i = 0; i < nnop; ++i) {
          evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms[" << Inop[i] - 1
                << "] * dYY" << Inop[i] - 1 << "[" << m << "]";
        }
        evalg << ") + dYrho[" << m << "]*(" << bodyCoeff[k][Iop[s] - 1]
              << "/Ms[" << Iop[s] - 1 << "]";
        for (int i = 0; i < nnop; ++i) {
          evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms[" << Inop[i] - 1
                << "] * dYY" << Inop[i] - 1 << "[" << s << "]";
        }
        evalg << ");" << endl;
      }
    }
  }
  evalg << endl;

  evalg << "   // Generate dYYG" << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYGp[" << r << "][" << s << "][" << m << "] = 0.0";
        if (s != m) {
          if ((nuprime[Iop[s] - 1][r] != 0) && (nuprime[Iop[m] - 1][r] != 0)) {
            evalg << " + (" << nuprime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
                  << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1 << "],"
                  << nuprime[Iop[m] - 1][r] - 1 << ") * ("
                  << nuprime[Iop[s] - 1][r] << ")/Ms[" << Iop[s] - 1
                  << "] * pow(Y[" << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1 << "],"
                  << nuprime[Iop[s] - 1][r] - 1 << ")";
            for (int i = 0; i < nop; ++i) {
              if ((i != s) && (i != m)) {
                for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                  evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                        << "]";
                }
              }
            }
          }
        } else {
          if (nuprime[Iop[s] - 1][r] > 1) {
            evalg << " + (" << nuprime[Iop[m] - 1][r] << ")*("
                  << nuprime[Iop[m] - 1][r] - 1 << ")/Ms[" << Iop[m] - 1
                  << "]/Ms[" << Iop[m] - 1 << "] * pow(Y[" << Iop[m] - 1
                  << "]/Ms[" << Iop[m] - 1 << "]," << nuprime[Iop[m] - 1][r] - 2
                  << ")";
            for (int i = 0; i < nop; ++i) {
              if (i != s) {
                for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                  evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                        << "]";
                }
              }
            }
          }
        }
        evalg << ";" << endl;
      }
    }
  }
  for (int r = 0; r < nreac; ++r) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYGm[" << r << "][" << s << "][" << m << "] = 0.0";
        if (s != m) {
          if ((nu2prime[Iop[s] - 1][r] != 0) &&
              (nu2prime[Iop[m] - 1][r] != 0)) {
            evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
                  << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1 << "],"
                  << nu2prime[Iop[m] - 1][r] - 1 << ") * ("
                  << nu2prime[Iop[s] - 1][r] << ")/Ms[" << Iop[s] - 1
                  << "] * pow(Y[" << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1 << "],"
                  << nu2prime[Iop[s] - 1][r] - 1 << ")";
            for (int i = 0; i < nop; ++i) {
              if ((i != s) && (i != m)) {
                for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                  evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                        << "]";
                }
              }
            }
          }
        } else {
          if (nu2prime[Iop[s] - 1][r] > 1) {
            evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")*("
                  << nu2prime[Iop[m] - 1][r] - 1 << ")/Ms[" << Iop[m] - 1
                  << "]/Ms[" << Iop[m] - 1 << "] * pow(Y[" << Iop[m] - 1
                  << "]/Ms[" << Iop[m] - 1 << "],"
                  << nu2prime[Iop[m] - 1][r] - 2 << ")";
            for (int i = 0; i < nop; ++i) {
              if (i != s) {
                for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                  evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                        << "]";
                }
              }
            }
          }
        }
        evalg << ";" << endl;
      }
    }
  }
  evalg << endl;

  evalg << "   // Generate dYYR" << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYRp[" << r << "][" << s << "][" << m << "] = 0.0";
        for (int i = 0; i < nnop; ++i) {
          if (nuprime[Inop[i] - 1][r] != 0) {
            evalg << " + (" << nuprime[Inop[i] - 1][r] << ")/pow(Ms["
                  << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r] << ") * ( ("
                  << nuprime[Inop[i] - 1][r] - 1 << ") * pow(Y[" << Inop[i] - 1
                  << "]," << nuprime[Inop[i] - 1][r] - 2 << ") * dYY"
                  << Inop[i] - 1 << "[" << s << "] * dYY" << Inop[i] - 1 << "["
                  << m << "]";
            for (int j = 0; j < nnop; ++j) {
              if ((nuprime[Inop[j] - 1][r] != 0) && (j != i)) {
                evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms[" << Inop[j] - 1
                      << "]," << nuprime[Inop[j] - 1][r] << ")";
              }
            }
            evalg << " + pow(Y[" << Inop[i] - 1 << "],"
                  << nuprime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                  << "[" << s << "] * (0.0";
            for (int l = 0; l < nnop; ++l) {
              if (l != i) {
                if (nuprime[Inop[l] - 1][r] != 0) {
                  evalg << " + (" << nuprime[Inop[l] - 1][r] << ")/Ms["
                        << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1 << "]/Ms["
                        << Inop[l] - 1 << "]," << nuprime[Inop[l] - 1][r] - 1
                        << ") * dYY" << Inop[l] - 1 << "[" << m << "]";
                  for (int k = 0; k < nnop; ++k) {
                    if ((nuprime[Inop[k] - 1][r] != 0) && (k != i) &&
                        (k != l)) {
                      evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                            << Inop[k] - 1 << "]," << nuprime[Inop[k] - 1][r]
                            << ")";
                    }
                  }
                }
              }
            }
            evalg << "))";
          }
        }
        evalg << ";" << endl;
      }
    }
  }
  evalg << endl;
  for (int r = 0; r < nreac; ++r) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYRm[" << r << "][" << s << "][" << m << "] = 0.0";
        for (int i = 0; i < nnop; ++i) {
          if (nu2prime[Inop[i] - 1][r] != 0) {
            evalg << " + (" << nu2prime[Inop[i] - 1][r] << ")/pow(Ms["
                  << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r]
                  << ") * ( (" << nu2prime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                  << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r] - 2
                  << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                  << Inop[i] - 1 << "[" << m << "]";
            for (int j = 0; j < nnop; ++j) {
              if ((nu2prime[Inop[j] - 1][r] != 0) && (j != i)) {
                evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms[" << Inop[j] - 1
                      << "]," << nu2prime[Inop[j] - 1][r] << ")";
              }
            }
            evalg << " + pow(Y[" << Inop[i] - 1 << "],"
                  << nu2prime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                  << "[" << s << "] * (0.0";
            for (int l = 0; l < nnop; ++l) {
              if (l != i) {
                if (nu2prime[Inop[l] - 1][r] != 0) {
                  evalg << " + (" << nu2prime[Inop[l] - 1][r] << ")/Ms["
                        << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1 << "]/Ms["
                        << Inop[l] - 1 << "]," << nu2prime[Inop[l] - 1][r] - 1
                        << ") * dYY" << Inop[l] - 1 << "[" << m << "]";
                  for (int k = 0; k < nnop; ++k) {
                    if ((nu2prime[Inop[k] - 1][r] != 0) && (k != i) &&
                        (k != l)) {
                      evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                            << Inop[k] - 1 << "]," << nu2prime[Inop[k] - 1][r]
                            << ")";
                    }
                  }
                }
              }
            }
            evalg << "))";
          }
        }
        evalg << ";" << endl;
      }
    }
  }
  evalg << endl;

  // generating dYYqtilde
  evalg << endl << "   // Generate dYYqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }

    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYqtilde[" << i << "][" << s << "][" << m << "]  = kf["
              << i << "] * ( Gp[" << i << "] * ((" << nubarprime
              << ") * ( pow(rho," << nubarprime - 1 << ") * (dYrho[" << s
              << "] * dYRp[" << i << "][" << m << "] + dYrho[" << m
              << "] * dYRp[" << i << "][" << s << "] + dYYrho[" << s << "]["
              << m << "] * Rp[" << i << "])";
        evalg << " + (" << nubarprime - 1 << ") * pow(rho," << nubarprime - 2
              << ") * dYrho[" << m << "] * dYrho[" << s << "] * Rp[" << i
              << "]) + pow(rho," << nubarprime << ") * dYYRp[" << i << "][" << s
              << "][" << m << "])";
        evalg << " + dYGp[" << i << "][" << s << "] * ( (" << nubarprime
              << ") * pow(rho," << nubarprime - 1 << ") *dYrho[" << m
              << "] * Rp[" << i << "] + pow(rho," << nubarprime << ") * dYRp["
              << i << "][" << m << "])";
        evalg << " + dYGp[" << i << "][" << m << "] * ( (" << nubarprime
              << ") * pow(rho," << nubarprime - 1 << ") *dYrho[" << s
              << "] * Rp[" << i << "] + pow(rho," << nubarprime << ") * dYRp["
              << i << "][" << s << "])";
        evalg << " + dYYGp[" << i << "][" << s << "][" << m << "] * pow(rho,"
              << nubarprime << ") * Rp[" << i << "] )";
        evalg << " - kr[" << i << "] * ( Gm[" << i << "] * ((" << nubar2prime
              << ") * ( pow(rho," << nubar2prime - 1 << ") * (dYrho[" << s
              << "] * dYRm[" << i << "][" << m << "] + dYrho[" << m
              << "] * dYRm[" << i << "][" << s << "] + dYYrho[" << s << "]["
              << m << "] * Rm[" << i << "])";
        evalg << " + (" << nubar2prime - 1 << ") * pow(rho," << nubar2prime - 2
              << ") * dYrho[" << m << "] * dYrho[" << s << "] * Rm[" << i
              << "]) + pow(rho," << nubar2prime << ") * dYYRm[" << i << "]["
              << s << "][" << m << "])";
        evalg << " + dYGm[" << i << "][" << s << "] * ( (" << nubar2prime
              << ") * pow(rho," << nubar2prime - 1 << ") *dYrho[" << m
              << "] * Rm[" << i << "] + pow(rho," << nubar2prime << ") * dYRm["
              << i << "][" << m << "])";
        evalg << " + dYGm[" << i << "][" << m << "] * ( (" << nubar2prime
              << ") * pow(rho," << nubar2prime - 1 << ") *dYrho[" << s
              << "] * Rm[" << i << "] + pow(rho," << nubar2prime << ") * dYRm["
              << i << "][" << s << "])";
        evalg << " + dYYGm[" << i << "][" << s << "][" << m << "] * pow(rho,"
              << nubar2prime << ") * Rm[" << i << "]);" << endl;
      }
      evalg << endl;
    }
    evalg << endl;
  }

  // generating dTTqtilde
  evalg << endl << "   // Generate dTTqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }
    evalg << "   dTTqtilde[" << i << "]  = (dTTkf[" << i << "] - 2*("
          << nubarprime << ")/T * dTkf[" << i << "] + ((" << nubarprime << ")+("
          << nubarprime << ")*(" << nubarprime << "))/(T*T) * kf[" << i
          << "]) * pow(rho," << nubarprime << ") * Gp[" << i << "] * Rp[" << i
          << "]";
    evalg << "- (dTTkr[" << i << "] - 2*(" << nubar2prime << ")/T * dTkr[" << i
          << "] + ((" << nubar2prime << ")+(" << nubar2prime << ")*("
          << nubar2prime << "))/(T*T) * kr[" << i << "]) * pow(rho,"
          << nubar2prime << ") * Gm[" << i << "] * Rm[" << i << "];" << endl;
  }

  // generating dYYq
  evalg << endl << "   // Generate dYYq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);

    // if there isn't a thrid body
    if (ind == -1) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYq[" << i << "][" << s << "][" << m << "] = dYYqtilde["
                << i << "][" << s << "][" << m << "];" << endl;
        }
      }
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYq[" << i << "][" << s << "][" << m << "] = M["
                << whichThirdBody << "] * dYYqtilde[" << i << "][" << s << "]["
                << m << "] + dYM[" << whichThirdBody << "][" << s
                << "] * dYqtilde[" << i << "][" << m << "] + dYM["
                << whichThirdBody << "][" << m << "] * dYqtilde[" << i << "]["
                << s << "] + dYYM[" << whichThirdBody << "][" << s << "][" << m
                << "]*qtilde[" << i << "];" << endl;
        }
      }
    }
    evalg << endl;
  }

  // generating dTTq
  evalg << endl << "   // Generate dTTq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);

    // if there isn't a thrid body
    if (ind == -1) {
      evalg << "   dTTq[" << i << "] = dTTqtilde[" << i << "];" << endl;
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      evalg << "   dTTq[" << i << "] = M[" << whichThirdBody << "] * dTTqtilde["
            << i << "] + 2*dTM[" << whichThirdBody << "] * dTqtilde[" << i
            << "] + dTTM[" << whichThirdBody << "]*qtilde[" << i << "];"
            << endl;
    }
    evalg << endl;
  }

  // generating dYYomega
  evalg << endl << "   // Generate dYYomega" << endl;
  for (int i = 0; i < nop; ++i) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYomega[" << i << "][" << s << "][" << m << "]  = 0.0";
        for (int r = 0; r < nreac; ++r) {
          if (nu[Iop[i] - 1][r] != 0)
            evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYYq[" << r << "]["
                  << s << "][" << m << "]";
        }
        evalg << ";" << endl;
      }
      evalg << endl;
    }
    evalg << endl;
  }
  evalg << endl;

  // generating dTTomega
  evalg << endl << "   // Generate dTTomega" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   dTTomega[" << i << "] = 0.0";
    for (int r = 0; r < nreac; ++r) {
      if (nu[Iop[i] - 1][r] != 0)
        evalg << " + (" << nu[Iop[i] - 1][r] << ") * dTTq[" << r << "]";
    }
    evalg << ";" << endl;
  }
  evalg << endl;

  // generating dYYf
  evalg << endl << "   // Generate dYYf" << endl;
  for (int i = 0; i < nop; ++i) {
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        evalg << "   dYYf[" << i << "][" << s << "][" << m << "]  = Ms["
              << Iop[i] - 1 << "] * ( 2.0/(rho*rho*rho) * omega[" << i
              << "] * dYrho[" << s << "] * dYrho[" << m
              << "] - 1.0/(rho*rho) * ( dYrho[" << m << "] * dYomega[" << i
              << "][" << s << "] + dYrho[" << s << "] * dYomega[" << i << "]["
              << m << "] + omega[" << i << "] * dYYrho[" << s << "][" << m
              << "]) + 1/rho * dYYomega[" << i << "][" << s << "][" << m
              << "]);" << endl;
      }
      evalg << endl;
    }
    evalg << endl;
  }
  evalg << endl;

  // generating dTTf
  evalg << endl << "   // Generate dTTf" << endl;
  for (int i = 0; i < nop; ++i) {
    evalg << "   dTTf[" << i << "]  = Ms[" << Iop[i] - 1
          << "]/rho * ( dTTomega[" << i << "] + 2/T * dTomega[" << i << "] );"
          << endl;
  }
  evalg << endl;

  // generating dYTrho
  evalg << endl << "   // Generate dYTrho" << endl;
  for (int s = 0; s < nop; ++s) {
    evalg << "   dYTrho[" << s << "] =- dYrho[" << s << "]/T;" << endl;
  }
  evalg << endl;

  // generating dTM
  evalg << "   // Generate dYTM" << endl;
  for (int k = 0; k < bodyCoeff.size(); ++k) {
    evalg << "   // third body #" << k + 1 << endl;
    for (int s = 0; s < nop; ++s) {
      evalg << "   dYTM[" << k << "][" << s << "] = -dYM[" << k << "][" << s
            << "]/T;" << endl;
    }
  }

  // generating dYTqtilde
  evalg << endl << "   // Generate dYTqtilde" << endl;
  for (int i = 0; i < nreac; ++i) {
    int nubarprime = 0;
    int nubar2prime = 0;
    for (int s = 0; s < nspec; ++s) {
      nubarprime += nuprime[s][i];
      nubar2prime += nu2prime[s][i];
    }

    for (int s = 0; s < nop; ++s) {
      evalg << "   dYTqtilde[" << i << "][" << s << "]  = ( dTkf[" << i
            << "] - kf[" << i << "]*(" << nubarprime << ")/T )  * ( Gp[" << i
            << "] * ( (" << nubarprime << ") * pow(rho," << nubarprime - 1
            << ") * dYrho[" << s << "] * Rp[" << i << "] + pow(rho,"
            << nubarprime << ") * dYRp[" << i << "][" << s << "]) + dYGp[" << i
            << "][" << s << "] * pow(rho," << nubarprime << ") * Rp[" << i
            << "])";
      evalg << " - ( dTkr[" << i << "] - kr[" << i << "]*(" << nubar2prime
            << ")/T )  * ( Gm[" << i << "] * ( (" << nubar2prime
            << ") * pow(rho," << nubar2prime - 1 << ") * dYrho[" << s
            << "] * Rm[" << i << "] + pow(rho," << nubar2prime << ") * dYRm["
            << i << "][" << s << "]) + dYGm[" << i << "][" << s
            << "] * pow(rho," << nubar2prime << ") * Rm[" << i << "] );"
            << endl;
    }
    evalg << endl;
  }

  // generating dYTq
  evalg << endl << "   // Generate dYTq" << endl;
  for (int i = 0; i < nreac; ++i) {
    int ind = thirdBodyOccurs(bodyPos, i);
    // if there isn't a thrid body
    if (ind == -1) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTq[" << i << "][" << s << "] = dYTqtilde[" << i << "]["
              << s << "];" << endl;
      }
      // otherwise use product rule
    } else {
      int whichThirdBody = bodyNumber[ind] - 1;
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTq[" << i << "][" << s << "] = dYM[" << whichThirdBody
              << "][" << s << "] * dTqtilde[" << i << "] + dYTM["
              << whichThirdBody << "][" << s << "] * qtilde[" << i << "] + dTM["
              << whichThirdBody << "] *dYqtilde[" << i << "][" << s << "] + M["
              << whichThirdBody << "] * dYTqtilde[" << i << "][" << s << "];"
              << endl;
      }
    }
    evalg << endl;
  }

  // generating dYTomega
  evalg << endl << "   // Generate dYTomega" << endl;
  for (int i = 0; i < nop; ++i) {
    for (int s = 0; s < nop; ++s) {
      evalg << "   dYTomega[" << i << "][" << s << "]  = 0.0";
      for (int r = 0; r < nreac; ++r) {
        if (nu[Iop[i] - 1][r] != 0)
          evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYTq[" << r << "][" << s
                << "]";
      }
      evalg << ";" << endl;
    }
    evalg << endl;
  }
  evalg << endl;

  // generating dYTf
  evalg << endl << "   // Generate dYTf" << endl;
  for (int i = 0; i < nop; ++i) {
    for (int m = 0; m < nop; ++m) {
      evalg << "   dYTf[" << i << "][" << m << "]  = Ms[" << Iop[i] - 1
            << "]/rho * ( dYTomega[" << i << "][" << m << "] + dYomega[" << i
            << "][" << m << "]/T - dYrho[" << m << "]/rho * ( dTomega[" << i
            << "] + omega[" << i << "]/T) );" << endl;
    }
    evalg << endl;
  }

  // close function
  evalg << endl << "}" << endl;

  /*****************
   *   getThridDerivative_f
   *****************/

  evalg << "void ammsockNLP::getThirdDerivative_f(const Number T, const Number "
           "_Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "], Number dTTf[" << nop
        << "], Number dYYYf[" << nop << "][" << nop << "][" << nop << "]["
        << nop << "], Number dYYTf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTTf[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec
        << "], Number Yres[" << nnop << "], Number dYYres[" << nnop << "]["
        << nop << "]) {" << endl
        << endl;

  evalg << "   Number rho, dYrho[" << nop << "], dTrho, dYYrho[" << nop << "]["
        << nop << "], dYTrho[" << nop << "], dTTrho, dYYYrho[" << nop << "]["
        << nop << "][" << nop << "];" << endl;
  evalg << "   Number Mbar, dYMbar[" << nop << "], dYYMbar[" << nop << "]["
        << nop << "];" << endl;
  evalg << "   Number q[" << nreac << "], dYq[" << nreac << "][" << nop
        << "], dTq[" << nreac << "],  dYYq[" << nreac << "][" << nop << "]["
        << nop << "], dYTq[" << nreac << "][" << nop << "], dTTq[" << nreac
        << "], dYYYq[" << nreac << "][" << nop << "][" << nop << "][" << nop
        << "], dYYTq[" << nreac << "][" << nop << "][" << nop << "], dYTTq["
        << nreac << "][" << nop << "];" << endl;
  evalg << "   Number qtilde[" << nreac << "], dYqtilde[" << nreac << "]["
        << nop << "], dTqtilde[" << nreac << "], dYYqtilde[" << nreac << "]["
        << nop << "][" << nop << "], dYTqtilde[" << nreac << "][" << nop
        << "], dTTqtilde[" << nreac << "], dYYYqtilde[" << nreac << "][" << nop
        << "][" << nop << "][" << nop << "], dYYTqtilde[" << nreac << "]["
        << nop << "][" << nop << "], dYTTqtilde[" << nreac << "][" << nop
        << "];" << endl;
  evalg << "   Number omega[" << nop << "], dYomega[" << nop << "][" << nop
        << "], dTomega[" << nop << "], dYYomega[" << nop << "][" << nop << "]["
        << nop << "], dYTomega[" << nop << "][" << nop << "], dTTomega[" << nop
        << "], dYYYomega[" << nop << "][" << nop << "][" << nop << "][" << nop
        << "], dYYTomega[" << nop << "][" << nop << "][" << nop
        << "], dYTTomega[" << nop << "][" << nop << "];" << endl;
  evalg << "   Number M[" << ntb << "], dYM[" << ntb << "][" << nop << "], dTM["
        << ntb << "], dYYM[" << ntb << "][" << nop << "][" << nop << "], dYTM["
        << ntb << "][" << nop << "], dTTM[" << ntb << "], dYYYM[" << ntb << "]["
        << nop << "][" << nop << "][" << nop << "], dYYTM[" << ntb << "]["
        << nop << "][" << nop << "], dYTTM[" << ntb << "][" << nop << "];"
        << endl;
  evalg << "   Number Gp[" << nreac << "], dYGp[" << nreac << "][" << nop
        << "], dYYGp[" << nreac << "][" << nop << "][" << nop << "], dYYYGp["
        << nreac << "][" << nop << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Gm[" << nreac << "], dYGm[" << nreac << "][" << nop
        << "], dYYGm[" << nreac << "][" << nop << "][" << nop << "], dYYYGm["
        << nreac << "][" << nop << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rp[" << nreac << "], dYRp[" << nreac << "][" << nop
        << "], dYYRp[" << nreac << "][" << nop << "][" << nop << "], dYYYRp["
        << nreac << "][" << nop << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number Rm[" << nreac << "], dYRm[" << nreac << "][" << nop
        << "], dYYRm[" << nreac << "][" << nop << "][" << nop << "], dYYYRm["
        << nreac << "][" << nop << "][" << nop << "][" << nop << "];" << endl;
  evalg << "   Number kf[" << nreac << "], dTkf[" << nreac << "], dTTkf["
        << nreac << "];" << endl;
  evalg << "   Number kr[" << nreac << "], dTkr[" << nreac << "], dTTkr["
        << nreac << "];" << endl;

  evalg << "   //set resolved species and their derivatives" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Yres[" << i << "] = Y" << Inop[i] - 1 << "RES;" << endl;
  }
  evalg << endl;
  evalg << "   //define derivatives of resolutions" << endl;
  for (int i = 0; i < nnop; ++i) {
    evalg << "   Number dYY" << i << "[" << nop << "] =  DIFFY" << Inop[i] - 1
          << "RES;" << endl;
  }
  for (int i = 0; i < nnop; ++i) {
    for (int j = 0; j < nop; ++j) {
      evalg << "   dYYres[" << i << "][" << j << "] = dYY" << i << "[" << j
            << "];" << endl;
    }
  }
  evalg << endl;

  evalg
      << "   "
         "getThirdDerivative_f(T,_Y,f,dYf,dTf,dYYf,dYTf,dTTf,dYYYf,dYYTf,dYTTf,"
         "rho,dYrho,dTrho,dYYrho,dYTrho,dTTrho,dYYYrho,Mbar,dYMbar,dYYMbar,q,"
         "dYq,dTq,dYYq,dYTq,dTTq,dYYYq,dYYTq,dYTTq,qtilde,dYqtilde,dTqtilde,"
         "dYYqtilde,dYTqtilde,dTTqtilde,dYYYqtilde,dYYTqtilde,dYTTqtilde,omega,"
         "dYomega,dTomega,dYYomega,dYTomega,dTTomega,dYYYomega,dYYTomega,"
         "dYTTomega,M,dYM,dTM,dYYM,dYTM,dTTM,dYYYM,dYYTM,dYTTM,Gp,dYGp,dYYGp,"
         "dYYYGp,Gm,dYGm,dYYGm,dYYYGm,Rp,dYRp,dYYRp,dYYYRp,Rm,dYRm,dYYRm,"
         "dYYYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
      << endl;

  // close function
  evalg << endl << "}" << endl << endl;

  evalg << "void ammsockNLP::getThirdDerivative_f(const Number T, const Number "
           "_Y["
        << nop << "]," << endl;
  evalg << "					Number f[" << nop
        << "], Number dYf[" << nop << "][" << nop << "], Number dTf[" << nop
        << "], Number dYYf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTf[" << nop << "][" << nop << "], Number dTTf[" << nop
        << "], Number dYYYf[" << nop << "][" << nop << "][" << nop << "]["
        << nop << "], Number dYYTf[" << nop << "][" << nop << "][" << nop
        << "], Number dYTTf[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number &rho, Number dYrho["
        << nop << "], Number &dTrho, Number dYYrho[" << nop << "][" << nop
        << "], Number dYTrho[" << nop << "], Number &dTTrho, Number dYYYrho["
        << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number &Mbar, Number dYMbar["
        << nop << "], Number dYYMbar[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number q[" << nreac
        << "], Number dYq[" << nreac << "][" << nop << "], Number dTq[" << nreac
        << "],  Number dYYq[" << nreac << "][" << nop << "][" << nop
        << "], Number dYTq[" << nreac << "][" << nop << "], Number dTTq["
        << nreac << "], Number dYYYq[" << nreac << "][" << nop << "][" << nop
        << "][" << nop << "], Number dYYTq[" << nreac << "][" << nop << "]["
        << nop << "], Number dYTTq[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number qtilde[" << nreac
        << "], Number dYqtilde[" << nreac << "][" << nop
        << "], Number dTqtilde[" << nreac << "], Number dYYqtilde[" << nreac
        << "][" << nop << "][" << nop << "], Number dYTqtilde[" << nreac << "]["
        << nop << "], Number dTTqtilde[" << nreac << "], Number dYYYqtilde["
        << nreac << "][" << nop << "][" << nop << "][" << nop
        << "], Number dYYTqtilde[" << nreac << "][" << nop << "][" << nop
        << "], Number dYTTqtilde[" << nreac << "][" << nop << "]," << endl;
  evalg << "					Number omega[" << nop
        << "], Number dYomega[" << nop << "][" << nop << "], Number dTomega["
        << nop << "], Number dYYomega[" << nop << "][" << nop << "][" << nop
        << "], Number dYTomega[" << nop << "][" << nop << "], Number dTTomega["
        << nop << "], Number dYYYomega[" << nop << "][" << nop << "][" << nop
        << "][" << nop << "], Number dYYTomega[" << nop << "][" << nop << "]["
        << nop << "], Number dYTTomega[" << nop << "][" << nop << "]," << endl;
  evalg << "					Number M[" << ntb
        << "], Number dYM[" << ntb << "][" << nop << "], Number dTM[" << ntb
        << "], Number dYYM[" << ntb << "][" << nop << "][" << nop
        << "], Number dYTM[" << ntb << "][" << nop << "], Number dTTM[" << ntb
        << "], Number dYYYM[" << ntb << "][" << nop << "][" << nop << "]["
        << nop << "], Number dYYTM[" << ntb << "][" << nop << "][" << nop
        << "], Number dYTTM[" << ntb << "][" << nop << "]," << endl;
  evalg << "					Number Gp[" << nreac
        << "], Number dYGp[" << nreac << "][" << nop << "], Number dYYGp["
        << nreac << "][" << nop << "][" << nop << "], Number dYYYGp[" << nreac
        << "][" << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Gm[" << nreac
        << "], Number dYGm[" << nreac << "][" << nop << "], Number dYYGm["
        << nreac << "][" << nop << "][" << nop << "], Number dYYYGm[" << nreac
        << "][" << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Rp[" << nreac
        << "], Number dYRp[" << nreac << "][" << nop << "], Number dYYRp["
        << nreac << "][" << nop << "][" << nop << "], Number dYYYRp[" << nreac
        << "][" << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number Rm[" << nreac
        << "], Number dYRm[" << nreac << "][" << nop << "], Number dYYRm["
        << nreac << "][" << nop << "][" << nop << "], Number dYYYRm[" << nreac
        << "][" << nop << "][" << nop << "][" << nop << "]," << endl;
  evalg << "					Number kf[" << nreac
        << "], Number dTkf[" << nreac << "], Number dTTkf[" << nreac << "],"
        << endl;
  evalg << "					Number kr[" << nreac
        << "], Number dTkr[" << nreac << "], Number dTTkr[" << nreac << "],"
        << endl;
  evalg << "					Number H[" << nspec
        << "], Number dTH[" << nspec << "], Number dTTH[" << nspec << "]) {"
        << endl
        << endl;
  if (EXACTHESSIAN) {
    // get variables and molar weights
    evalg << "   // Preliminaries" << endl;
    evalg << "   Number Y[" << nspec << "];" << endl;
    for (int i = 0; i < nop; ++i) {
      evalg << "   Y[" << Iop[i] - 1 << "] = _Y[" << i << "];" << endl;
    }
    for (int i = 0; i < nnop; ++i) {
      evalg << "   Y[" << Inop[i] - 1 << "] = Y" << Inop[i] - 1 << "RES;"
            << endl;
    }
    evalg << "   //define derivatives of resolutions" << endl;
    for (int i = 0; i < nnop; ++i) {
      evalg << "   Number dYY" << Inop[i] - 1 << "[" << nop << "] =  DIFFY"
            << Inop[i] - 1 << "RES;" << endl;
    }

    evalg << "   Number Ms[" << nspec << "] = { " << std::setprecision(15)
          << 1e-3 * Ms[0];
    for (int i = 1; i < Ms.size(); ++i) {
      evalg << ", " << 1e-3 * Ms[i];
    }
    evalg << "}; //molar weights in kg/mol" << endl;
    evalg << endl;

    evalg << "   //get secound derivatives" << endl;
    evalg << "   "
             "getSecondDerivative_f(T,_Y,f,dYf,dTf,dYYf,dYTf,dTTf,rho,dYrho,"
             "dTrho,dYYrho,dYTrho,dTTrho,Mbar,dYMbar,dYYMbar,q,dYq,dTq,dYYq,"
             "dYTq,dTTq,qtilde,dYqtilde,dTqtilde,dYYqtilde,dYTqtilde,dTTqtilde,"
             "omega,dYomega,dTomega,dYYomega,dYTomega,dTTomega,M,dYM,dTM,dYYM,"
             "dYTM,dTTM,Gp,dYGp,dYYGp,Gm,dYGm,dYYGm,Rp,dYRp,dYYRp,Rm,dYRm,"
             "dYYRm,kf,dTkf,dTTkf,kr,dTkr,dTTkr,H,dTH,dTTH);"
          << endl;
    evalg << endl;

    // generating dYYYrho
    evalg << "   // Generate dYYYrho" << endl;
    for (int s = 0; s < nop; ++s) {
      for (int m = 0; m < nop; ++m) {
        for (int k = 0; k < nop; ++k) {
          evalg << "   dYYYrho[" << s << "][" << m << "][" << k
                << "] = -( dYYMbar[" << m << "][" << k << "] * rho + dYMbar["
                << m << "] * dYrho[" << k << "] + dYMbar[" << k << "] * dYrho["
                << m << "] + Mbar * dYYrho[" << m << "][" << k << "]) * (1/Ms["
                << Iop[s] - 1 << "]";
          for (int i = 0; i < nnop; ++i) {
            evalg << " + 1.0/Ms[" << Inop[i] - 1 << "] * dYY" << Inop[i] - 1
                  << "[" << s << "]";
          }
          evalg << ");" << endl;
        }
      }
      evalg << endl;
    }

    // generating dYTTM, dYYTM, dYYYM
    evalg << "   // Generate dYTTM, dYYTM and dYYYM" << endl;
    evalg << "   Number sumAlphaYM = 0.0;" << endl;
    for (int k = 0; k < bodyCoeff.size(); ++k) {
      evalg << "   // third body #" << k + 1 << endl;
      evalg << "   sumAlphaYM = 0.0 ";
      for (int s = 0; s < nspec; ++s) {
        evalg << " + " << bodyCoeff[k][s] << " * Y[" << s << "]/Ms[" << s
              << "]";
      }
      evalg << ";" << endl;
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTTM[" << k << "][" << s << "] = 2/(T*T) * dYM[" << k
              << "][" << s << "];" << endl;
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYTM[" << k << "][" << s << "][" << m
                << "] = - 1/T * dYYM[" << k << "][" << s << "][" << m << "];"
                << endl;
          for (int l = 0; l < nop; ++l) {
            evalg << "   dYYYM[" << k << "][" << s << "][" << m << "][" << l
                  << "] = dYYYrho[" << s << "][" << m << "][" << l
                  << "]*sumAlphaYM + dYYrho[" << s << "][" << l << "]*("
                  << bodyCoeff[k][Iop[m] - 1] << "/Ms[" << Iop[m] - 1 << "]";
            for (int i = 0; i < nnop; ++i) {
              evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms["
                    << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << m
                    << "]";
            }
            evalg << ") + dYYrho[" << m << "][" << l << "]*("
                  << bodyCoeff[k][Iop[s] - 1] << "/Ms[" << Iop[s] - 1 << "]";
            for (int i = 0; i < nnop; ++i) {
              evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms["
                    << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << s
                    << "]";
            }
            evalg << ") + dYYrho[" << s << "][" << m << "]*("
                  << bodyCoeff[k][Iop[l] - 1] << "/Ms[" << Iop[l] - 1 << "]";
            for (int i = 0; i < nnop; ++i) {
              evalg << " + " << bodyCoeff[k][Inop[i] - 1] << "/Ms["
                    << Inop[i] - 1 << "] * dYY" << Inop[i] - 1 << "[" << l
                    << "]";
            }
            evalg << ");" << endl;
          }
        }
      }
    }
    evalg << endl;

    // generating general terms
    evalg << "   // Generate dYYYG" << endl;
    for (int r = 0; r < nreac; ++r) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYGp[" << r << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            if ((s != m) && (m != k) && (s != k)) {
              if ((nuprime[Iop[s] - 1][r] != 0) &&
                  (nuprime[Iop[m] - 1][r] != 0) &&
                  (nuprime[Iop[k] - 1][r] != 0)) {
                evalg << " + (" << nuprime[Iop[m] - 1][r] << ")/Ms["
                      << Iop[m] - 1 << "] * pow(Y[" << Iop[m] - 1 << "]/Ms["
                      << Iop[m] - 1 << "]," << nuprime[Iop[m] - 1][r] - 1
                      << ") * (" << nuprime[Iop[s] - 1][r] << ")/Ms["
                      << Iop[s] - 1 << "] * pow(Y[" << Iop[s] - 1 << "]/Ms["
                      << Iop[s] - 1 << "]," << nuprime[Iop[s] - 1][r] - 1
                      << ") * (" << nuprime[Iop[k] - 1][r] << ")/Ms["
                      << Iop[k] - 1 << "] * pow(Y[" << Iop[k] - 1 << "]/Ms["
                      << Iop[k] - 1 << "]," << nuprime[Iop[k] - 1][r] - 1
                      << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s != m) && (s == k)) {
              if ((nuprime[Iop[s] - 1][r] > 1) &&
                  (nuprime[Iop[m] - 1][r] != 0)) {
                evalg << " + (" << nuprime[Iop[s] - 1][r] << ")*("
                      << nuprime[Iop[s] - 1][r] - 1 << ")/(Ms[" << Iop[s] - 1
                      << "]*Ms[" << Iop[s] - 1 << "]) * pow(Y[" << Iop[s] - 1
                      << "]/Ms[" << Iop[s] - 1 << "],"
                      << nuprime[Iop[s] - 1][r] - 2 << ") * ("
                      << nuprime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
                      << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1
                      << "]," << nuprime[Iop[m] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s != m) && (m == k)) {
              if ((nuprime[Iop[m] - 1][r] > 1) &&
                  (nuprime[Iop[s] - 1][r] != 0)) {
                evalg << " + (" << nuprime[Iop[m] - 1][r] << ")*("
                      << nuprime[Iop[m] - 1][r] - 1 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]) * pow(Y[" << Iop[m] - 1
                      << "]/Ms[" << Iop[m] - 1 << "],"
                      << nuprime[Iop[m] - 1][r] - 2 << ") * ("
                      << nuprime[Iop[s] - 1][r] << ")/Ms[" << Iop[s] - 1
                      << "] * pow(Y[" << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1
                      << "]," << nuprime[Iop[s] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s == m) && (s != k)) {
              if ((nuprime[Iop[m] - 1][r] > 1) &&
                  (nuprime[Iop[k] - 1][r] != 0)) {
                evalg << " + (" << nuprime[Iop[m] - 1][r] << ")*("
                      << nuprime[Iop[m] - 1][r] - 1 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]) * pow(Y[" << Iop[m] - 1
                      << "]/Ms[" << Iop[m] - 1 << "],"
                      << nuprime[Iop[m] - 1][r] - 2 << ") * ("
                      << nuprime[Iop[k] - 1][r] << ")/Ms[" << Iop[k] - 1
                      << "] * pow(Y[" << Iop[k] - 1 << "]/Ms[" << Iop[k] - 1
                      << "]," << nuprime[Iop[k] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s == m) && (m == k)) {
              if ((nuprime[Iop[m] - 1][r] > 2)) {
                evalg << " + (" << nuprime[Iop[m] - 1][r] << ")*("
                      << nuprime[Iop[m] - 1][r] - 1 << ")*("
                      << nuprime[Iop[m] - 1][r] - 2 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]*Ms[" << Iop[m] - 1
                      << "]) * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1
                      << "]," << nuprime[Iop[m] - 1][r] - 3 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nuprime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            evalg << ";" << endl;
          }
        }
      }
    }
    for (int r = 0; r < nreac; ++r) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYGm[" << r << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            if ((s != m) && (m != k) && (s != k)) {
              if ((nu2prime[Iop[s] - 1][r] != 0) &&
                  (nu2prime[Iop[m] - 1][r] != 0) &&
                  (nu2prime[Iop[k] - 1][r] != 0)) {
                evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")/Ms["
                      << Iop[m] - 1 << "] * pow(Y[" << Iop[m] - 1 << "]/Ms["
                      << Iop[m] - 1 << "]," << nu2prime[Iop[m] - 1][r] - 1
                      << ") * (" << nu2prime[Iop[s] - 1][r] << ")/Ms["
                      << Iop[s] - 1 << "] * pow(Y[" << Iop[s] - 1 << "]/Ms["
                      << Iop[s] - 1 << "]," << nu2prime[Iop[s] - 1][r] - 1
                      << ") * (" << nu2prime[Iop[k] - 1][r] << ")/Ms["
                      << Iop[k] - 1 << "] * pow(Y[" << Iop[k] - 1 << "]/Ms["
                      << Iop[k] - 1 << "]," << nu2prime[Iop[k] - 1][r] - 1
                      << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s != m) && (s == k)) {
              if ((nu2prime[Iop[s] - 1][r] > 1) &&
                  (nu2prime[Iop[m] - 1][r] != 0)) {
                evalg << " + (" << nu2prime[Iop[s] - 1][r] << ")*("
                      << nu2prime[Iop[s] - 1][r] - 1 << ")/(Ms[" << Iop[s] - 1
                      << "]*Ms[" << Iop[s] - 1 << "]) * pow(Y[" << Iop[s] - 1
                      << "]/Ms[" << Iop[s] - 1 << "],"
                      << nu2prime[Iop[s] - 1][r] - 2 << ") * ("
                      << nu2prime[Iop[m] - 1][r] << ")/Ms[" << Iop[m] - 1
                      << "] * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1
                      << "]," << nu2prime[Iop[m] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s != m) && (m == k)) {
              if ((nu2prime[Iop[m] - 1][r] > 1) &&
                  (nu2prime[Iop[s] - 1][r] != 0)) {
                evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")*("
                      << nu2prime[Iop[m] - 1][r] - 1 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]) * pow(Y[" << Iop[m] - 1
                      << "]/Ms[" << Iop[m] - 1 << "],"
                      << nu2prime[Iop[m] - 1][r] - 2 << ") * ("
                      << nu2prime[Iop[s] - 1][r] << ")/Ms[" << Iop[s] - 1
                      << "] * pow(Y[" << Iop[s] - 1 << "]/Ms[" << Iop[s] - 1
                      << "]," << nu2prime[Iop[s] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s == m) && (s != k)) {
              if ((nu2prime[Iop[m] - 1][r] > 1) &&
                  (nu2prime[Iop[k] - 1][r] != 0)) {
                evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")*("
                      << nu2prime[Iop[m] - 1][r] - 1 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]) * pow(Y[" << Iop[m] - 1
                      << "]/Ms[" << Iop[m] - 1 << "],"
                      << nu2prime[Iop[m] - 1][r] - 2 << ") * ("
                      << nu2prime[Iop[k] - 1][r] << ")/Ms[" << Iop[k] - 1
                      << "] * pow(Y[" << Iop[k] - 1 << "]/Ms[" << Iop[k] - 1
                      << "]," << nu2prime[Iop[k] - 1][r] - 1 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            if ((s == m) && (m == k)) {
              if ((nu2prime[Iop[m] - 1][r] > 2)) {
                evalg << " + (" << nu2prime[Iop[m] - 1][r] << ")*("
                      << nu2prime[Iop[m] - 1][r] - 1 << ")*("
                      << nu2prime[Iop[m] - 1][r] - 2 << ")/(Ms[" << Iop[m] - 1
                      << "]*Ms[" << Iop[m] - 1 << "]*Ms[" << Iop[m] - 1
                      << "]) * pow(Y[" << Iop[m] - 1 << "]/Ms[" << Iop[m] - 1
                      << "]," << nu2prime[Iop[m] - 1][r] - 3 << ")";
                for (int i = 0; i < nop; ++i) {
                  if ((i != s) && (i != m) && (i != k)) {
                    for (int l = 1; l <= nu2prime[Iop[i] - 1][r]; ++l) {
                      evalg << " * Y[" << Iop[i] - 1 << "]/Ms[" << Iop[i] - 1
                            << "]";
                    }
                  }
                }
              }
            }
            evalg << ";" << endl;
          }
        }
      }
    }
    evalg << endl;

    // generate rest terms
    evalg << "   // Generate dYYYR" << endl;
    for (int r = 0; r < nreac; ++r) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYRp[" << r << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            for (int i = 0; i < nnop; ++i) {
              if (nuprime[Inop[i] - 1][r] != 0) {
                evalg << " + (" << nuprime[Inop[i] - 1][r] << ")/pow(Ms["
                      << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r]
                      << ") * ( (" << nuprime[Inop[i] - 1][r] - 1 << ")*("
                      << nuprime[Inop[i] - 1][r] - 2 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r] - 3
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << m << "] * dYY" << Inop[i] - 1
                      << "[" << k << "]";
                for (int j = 0; j < nnop; ++j) {
                  if ((nuprime[Inop[j] - 1][r] != 0) && (j != i)) {
                    evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                          << Inop[j] - 1 << "]," << nuprime[Inop[j] - 1][r]
                          << ")";
                  }
                }
                evalg << " + (" << nuprime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r] - 2
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << m << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if (l != i) {
                    if (nuprime[Inop[l] - 1][r] != 0) {
                      evalg << " + (" << nuprime[Inop[l] - 1][r] << ")/Ms["
                            << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1
                            << "]/Ms[" << Inop[l] - 1 << "],"
                            << nuprime[Inop[l] - 1][r] - 1 << ") * dYY"
                            << Inop[l] - 1 << "[" << k << "]";
                      for (int k = 0; k < nnop; ++k) {
                        if ((nuprime[Inop[k] - 1][r] != 0) && (k != i) &&
                            (k != l)) {
                          evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                                << Inop[k] - 1 << "],"
                                << nuprime[Inop[k] - 1][r] << ")";
                        }
                      }
                    }
                  }
                }
                evalg << ") + (" << nuprime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nuprime[Inop[i] - 1][r] - 2
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << k << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if (l != i) {
                    if (nuprime[Inop[l] - 1][r] != 0) {
                      evalg << " + (" << nuprime[Inop[l] - 1][r] << ")/Ms["
                            << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1
                            << "]/Ms[" << Inop[l] - 1 << "],"
                            << nuprime[Inop[l] - 1][r] - 1 << ") * dYY"
                            << Inop[l] - 1 << "[" << m << "]";
                      for (int k = 0; k < nnop; ++k) {
                        if ((nuprime[Inop[k] - 1][r] != 0) && (k != i) &&
                            (k != l)) {
                          evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                                << Inop[k] - 1 << "],"
                                << nuprime[Inop[k] - 1][r] << ")";
                        }
                      }
                    }
                  }
                }
                evalg << ") + pow(Y[" << Inop[i] - 1 << "],"
                      << nuprime[Inop[i] - 1][r] - 1 << ") * dYY" << Inop[i] - 1
                      << "[" << s << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if ((nuprime[Inop[l] - 1][r] != 0) && (l != i)) {
                    evalg << "+ (" << nuprime[Inop[l] - 1][r] << ")/pow(Ms["
                          << Inop[l] - 1 << "]," << nuprime[Inop[l] - 1][r]
                          << ") * ( (" << nuprime[Inop[l] - 1][r] - 1
                          << ") * pow(Y[" << Inop[l] - 1 << "],"
                          << nuprime[Inop[l] - 1][r] - 2 << ") * dYY"
                          << Inop[l] - 1 << "[" << k << "] * dYY" << Inop[l] - 1
                          << "[" << m << "]";
                    for (int j = 0; j < nnop; ++j) {
                      if ((nuprime[Inop[j] - 1][r] != 0) && (j != l) &&
                          (j != i)) {
                        evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                              << Inop[j] - 1 << "]," << nuprime[Inop[j] - 1][r]
                              << ")";
                      }
                    }
                    evalg << " + pow(Y[" << Inop[l] - 1 << "],"
                          << nuprime[Inop[l] - 1][r] - 1 << ") *  dYY"
                          << Inop[l] - 1 << "[" << m << "] * (0.0";
                    for (int p = 0; p < nnop; ++p) {
                      if ((p != l) && (p != i)) {
                        if (nuprime[Inop[p] - 1][r] != 0) {
                          evalg << " + (" << nuprime[Inop[p] - 1][r] << ")/Ms["
                                << Inop[p] - 1 << "] * pow(Y[" << Inop[p] - 1
                                << "]/Ms[" << Inop[p] - 1 << "],"
                                << nuprime[Inop[p] - 1][r] - 1 << ") * dYY"
                                << Inop[p] - 1 << "[" << k << "]";
                          for (int j = 0; j < nnop; ++j) {
                            if ((nuprime[Inop[j] - 1][r] != 0) && (j != i) &&
                                (j != l) && (j != p)) {
                              evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                                    << Inop[j] - 1 << "],"
                                    << nuprime[Inop[j] - 1][r] << ")";
                            }
                          }
                        }
                      }
                    }
                    evalg << "))";
                  }
                }
                evalg << "))";
              }
            }
            evalg << ";" << endl;
          }
        }
      }
    }
    evalg << endl;
    for (int r = 0; r < nreac; ++r) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYRm[" << r << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            for (int i = 0; i < nnop; ++i) {
              if (nu2prime[Inop[i] - 1][r] != 0) {
                evalg << " + (" << nu2prime[Inop[i] - 1][r] << ")/pow(Ms["
                      << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r]
                      << ") * ( (" << nu2prime[Inop[i] - 1][r] - 1 << ")*("
                      << nu2prime[Inop[i] - 1][r] - 2 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r] - 3
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << m << "] * dYY" << Inop[i] - 1
                      << "[" << k << "]";
                for (int j = 0; j < nnop; ++j) {
                  if ((nu2prime[Inop[j] - 1][r] != 0) && (j != i)) {
                    evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                          << Inop[j] - 1 << "]," << nu2prime[Inop[j] - 1][r]
                          << ")";
                  }
                }
                evalg << " + (" << nu2prime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r] - 2
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << m << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if (l != i) {
                    if (nu2prime[Inop[l] - 1][r] != 0) {
                      evalg << " + (" << nu2prime[Inop[l] - 1][r] << ")/Ms["
                            << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1
                            << "]/Ms[" << Inop[l] - 1 << "],"
                            << nu2prime[Inop[l] - 1][r] - 1 << ") * dYY"
                            << Inop[l] - 1 << "[" << k << "]";
                      for (int k = 0; k < nnop; ++k) {
                        if ((nu2prime[Inop[k] - 1][r] != 0) && (k != i) &&
                            (k != l)) {
                          evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                                << Inop[k] - 1 << "],"
                                << nu2prime[Inop[k] - 1][r] << ")";
                        }
                      }
                    }
                  }
                }
                evalg << ") + (" << nu2prime[Inop[i] - 1][r] - 1 << ") * pow(Y["
                      << Inop[i] - 1 << "]," << nu2prime[Inop[i] - 1][r] - 2
                      << ") * dYY" << Inop[i] - 1 << "[" << s << "] * dYY"
                      << Inop[i] - 1 << "[" << k << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if (l != i) {
                    if (nu2prime[Inop[l] - 1][r] != 0) {
                      evalg << " + (" << nu2prime[Inop[l] - 1][r] << ")/Ms["
                            << Inop[l] - 1 << "] * pow(Y[" << Inop[l] - 1
                            << "]/Ms[" << Inop[l] - 1 << "],"
                            << nu2prime[Inop[l] - 1][r] - 1 << ") * dYY"
                            << Inop[l] - 1 << "[" << m << "]";
                      for (int k = 0; k < nnop; ++k) {
                        if ((nu2prime[Inop[k] - 1][r] != 0) && (k != i) &&
                            (k != l)) {
                          evalg << " * pow(Y[" << Inop[k] - 1 << "]/Ms["
                                << Inop[k] - 1 << "],"
                                << nu2prime[Inop[k] - 1][r] << ")";
                        }
                      }
                    }
                  }
                }
                evalg << ") + pow(Y[" << Inop[i] - 1 << "],"
                      << nu2prime[Inop[i] - 1][r] - 1 << ") * dYY"
                      << Inop[i] - 1 << "[" << s << "] * (0.0";
                for (int l = 0; l < nnop; ++l) {
                  if ((nu2prime[Inop[l] - 1][r] != 0) && (l != i)) {
                    evalg << "+ (" << nu2prime[Inop[l] - 1][r] << ")/pow(Ms["
                          << Inop[l] - 1 << "]," << nu2prime[Inop[l] - 1][r]
                          << ") * ( (" << nu2prime[Inop[l] - 1][r] - 1
                          << ") * pow(Y[" << Inop[l] - 1 << "],"
                          << nu2prime[Inop[l] - 1][r] - 2 << ") * dYY"
                          << Inop[l] - 1 << "[" << k << "] * dYY" << Inop[l] - 1
                          << "[" << m << "]";
                    for (int j = 0; j < nnop; ++j) {
                      if ((nu2prime[Inop[j] - 1][r] != 0) && (j != l) &&
                          (j != i)) {
                        evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                              << Inop[j] - 1 << "]," << nu2prime[Inop[j] - 1][r]
                              << ")";
                      }
                    }
                    evalg << " + pow(Y[" << Inop[l] - 1 << "],"
                          << nu2prime[Inop[l] - 1][r] - 1 << ") *  dYY"
                          << Inop[l] - 1 << "[" << m << "] * (0.0";
                    for (int p = 0; p < nnop; ++p) {
                      if ((p != l) && (p != i)) {
                        if (nu2prime[Inop[p] - 1][r] != 0) {
                          evalg << " + (" << nu2prime[Inop[p] - 1][r] << ")/Ms["
                                << Inop[p] - 1 << "] * pow(Y[" << Inop[p] - 1
                                << "]/Ms[" << Inop[p] - 1 << "],"
                                << nu2prime[Inop[p] - 1][r] - 1 << ") * dYY"
                                << Inop[p] - 1 << "[" << k << "]";
                          for (int j = 0; j < nnop; ++j) {
                            if ((nu2prime[Inop[j] - 1][r] != 0) && (j != i) &&
                                (j != l) && (j != p)) {
                              evalg << " * pow(Y[" << Inop[j] - 1 << "]/Ms["
                                    << Inop[j] - 1 << "],"
                                    << nu2prime[Inop[j] - 1][r] << ")";
                            }
                          }
                        }
                      }
                    }
                    evalg << "))";
                  }
                }
                evalg << "))";
              }
            }
            evalg << ";" << endl;
          }
        }
      }
    }
    evalg << endl;

    // generating dYYYqtilde
    evalg << endl << "   // Generate dYYYqtilde" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nubarprime = 0;
      int nubar2prime = 0;
      for (int s = 0; s < nspec; ++s) {
        nubarprime += nuprime[s][i];
        nubar2prime += nu2prime[s][i];
      }

      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYqtilde[" << i << "][" << s << "][" << m << "]["
                  << k << "]  = kf[" << i << "] * ( pow(rho," << nubarprime
                  << ") * ( dYYYRp[" << i << "][" << s << "][" << m << "][" << k
                  << "] * Gp[" << i << "] + Rp[" << i << "] * dYYYGp[" << i
                  << "][" << s << "][" << m << "][" << k << "]";
            evalg << " + dYYGp[" << i << "][" << s << "][" << k << "] * dYRp["
                  << i << "][" << m << "] + dYYGp[" << i << "][" << m << "]["
                  << k << "] * dYRp[" << i << "][" << s << "] + dYYGp[" << i
                  << "][" << s << "][" << m << "] * dYRp[" << i << "][" << k
                  << "]";
            evalg << " + dYGp[" << i << "][" << s << "] * dYYRp[" << i << "]["
                  << m << "][" << k << "] + dYGp[" << i << "][" << m
                  << "] * dYYRp[" << i << "][" << s << "][" << k << "] + dYGp["
                  << i << "][" << k << "] * dYYRp[" << i << "][" << s << "]["
                  << m << "])";
            evalg << " + (" << nubarprime << ") * pow(rho," << nubarprime - 1
                  << ") * ( Gp[" << i << "] * ( dYrho[" << k << "] * dYYRp["
                  << i << "][" << s << "][" << m << "] + dYrho[" << s
                  << "] * dYYRp[" << i << "][" << m << "][" << k << "] + dYrho["
                  << m << "] * dYYRp[" << i << "][" << s << "][" << k << "]";
            evalg << " + dYYrho[" << s << "][" << k << "] * dYRp[" << i << "]["
                  << m << "] + dYYrho[" << m << "][" << k << "] * dYRp[" << i
                  << "][" << s << "] + dYYrho[" << s << "][" << m << "] * dYRp["
                  << i << "][" << k << "] + dYYYrho[" << s << "][" << m << "]["
                  << k << "] * Rp[" << i << "]";
            evalg << ") + Rp[" << i << "] * ( dYrho[" << k << "] * dYYGp[" << i
                  << "][" << s << "][" << m << "] + dYrho[" << s << "] * dYYGp["
                  << i << "][" << m << "][" << k << "] + dYrho[" << m
                  << "] * dYYGp[" << i << "][" << s << "][" << k << "]";
            evalg << " + dYYrho[" << s << "][" << k << "] * dYGp[" << i << "]["
                  << m << "] + dYYrho[" << m << "][" << k << "] * dYGp[" << i
                  << "][" << s << "] + dYYrho[" << s << "][" << m << "] * dYGp["
                  << i << "][" << k << "])";
            evalg << " + dYGp[" << i << "][" << s << "] * ( dYRp[" << i << "]["
                  << k << "] * dYrho[" << m << "] + dYRp[" << i << "][" << m
                  << "] * dYrho[" << k << "])";
            evalg << " + dYGp[" << i << "][" << m << "] * ( dYRp[" << i << "]["
                  << k << "] * dYrho[" << s << "] + dYRp[" << i << "][" << s
                  << "] * dYrho[" << k << "])";
            evalg << " + dYGp[" << i << "][" << k << "] * ( dYRp[" << i << "]["
                  << m << "] * dYrho[" << s << "] + dYRp[" << i << "][" << s
                  << "] * dYrho[" << m << "]))";
            evalg << " + (" << nubarprime << ") * (" << nubarprime - 1
                  << ") * pow(rho," << nubarprime - 2 << ") * ( Gp[" << i
                  << "] * ( dYRp[" << i << "][" << s << "] * dYrho[" << m
                  << "] * dYrho[" << k << "] + dYRp[" << i << "][" << m
                  << "] * dYrho[" << s << "] * dYrho[" << k << "] + dYRp[" << i
                  << "][" << k << "] * dYrho[" << m << "] * dYrho[" << s << "]";
            evalg << " + (dYrho[" << k << "] * dYYrho[" << s << "][" << m
                  << "] + dYrho[" << s << "] * dYYrho[" << m << "][" << k
                  << "] + dYrho[" << m << "] * dYYrho[" << s << "][" << k
                  << "]) * Rp[" << i << "]";
            evalg << " ) + Rp[" << i << "] * ( dYGp[" << i << "][" << s
                  << "] * dYrho[" << m << "] * dYrho[" << k << "] + dYGp[" << i
                  << "][" << m << "] * dYrho[" << s << "] * dYrho[" << k
                  << "] + dYGp[" << i << "][" << k << "] * dYrho[" << m
                  << "] * dYrho[" << s << "] ))";
            evalg << " + (" << nubarprime << ") * (" << nubarprime - 1
                  << ") * (" << nubarprime - 2 << ") * pow(rho,"
                  << nubarprime - 3 << ") * dYrho[" << s << "] * dYrho[" << m
                  << "] * dYrho[" << k << "] * Gp[" << i << "] * Rp[" << i
                  << "])";
            evalg << " - (kr[" << i << "] * ( pow(rho," << nubar2prime
                  << ") * ( dYYYRm[" << i << "][" << s << "][" << m << "][" << k
                  << "] * Gm[" << i << "] + Rm[" << i << "] * dYYYGm[" << i
                  << "][" << s << "][" << m << "][" << k << "]";
            evalg << " + dYYGm[" << i << "][" << s << "][" << k << "] * dYRm["
                  << i << "][" << m << "] + dYYGm[" << i << "][" << m << "]["
                  << k << "] * dYRm[" << i << "][" << s << "] + dYYGm[" << i
                  << "][" << s << "][" << m << "] * dYRm[" << i << "][" << k
                  << "]";
            evalg << " + dYGm[" << i << "][" << s << "] * dYYRm[" << i << "]["
                  << m << "][" << k << "] + dYGm[" << i << "][" << m
                  << "] * dYYRm[" << i << "][" << s << "][" << k << "] + dYGm["
                  << i << "][" << k << "] * dYYRm[" << i << "][" << s << "]["
                  << m << "])";
            evalg << " + (" << nubar2prime << ") * pow(rho," << nubar2prime - 1
                  << ") * ( Gm[" << i << "] * ( dYrho[" << k << "] * dYYRm["
                  << i << "][" << s << "][" << m << "] + dYrho[" << s
                  << "] * dYYRm[" << i << "][" << m << "][" << k << "] + dYrho["
                  << m << "] * dYYRm[" << i << "][" << s << "][" << k << "]";
            evalg << " + dYYrho[" << s << "][" << k << "] * dYRm[" << i << "]["
                  << m << "] + dYYrho[" << m << "][" << k << "] * dYRm[" << i
                  << "][" << s << "] + dYYrho[" << s << "][" << m << "] * dYRm["
                  << i << "][" << k << "] + dYYYrho[" << s << "][" << m << "]["
                  << k << "] * Rm[" << i << "]";
            evalg << ") + Rm[" << i << "] * ( dYrho[" << k << "] * dYYGm[" << i
                  << "][" << s << "][" << m << "] + dYrho[" << s << "] * dYYGm["
                  << i << "][" << m << "][" << k << "] + dYrho[" << m
                  << "] * dYYGm[" << i << "][" << s << "][" << k << "]";
            evalg << " + dYYrho[" << s << "][" << k << "] * dYGm[" << i << "]["
                  << m << "] + dYYrho[" << m << "][" << k << "] * dYGm[" << i
                  << "][" << s << "] + dYYrho[" << s << "][" << m << "] * dYGm["
                  << i << "][" << k << "])";
            evalg << " + dYGm[" << i << "][" << s << "] * ( dYRm[" << i << "]["
                  << k << "] * dYrho[" << m << "] + dYRm[" << i << "][" << m
                  << "] * dYrho[" << k << "])";
            evalg << " + dYGm[" << i << "][" << m << "] * ( dYRm[" << i << "]["
                  << k << "] * dYrho[" << s << "] + dYRm[" << i << "][" << s
                  << "] * dYrho[" << k << "])";
            evalg << " + dYGm[" << i << "][" << k << "] * ( dYRm[" << i << "]["
                  << m << "] * dYrho[" << s << "] + dYRm[" << i << "][" << s
                  << "] * dYrho[" << m << "]))";
            evalg << " + (" << nubar2prime << ") * (" << nubar2prime - 1
                  << ") * pow(rho," << nubar2prime - 2 << ") * ( Gm[" << i
                  << "] * ( dYRm[" << i << "][" << s << "] * dYrho[" << m
                  << "] * dYrho[" << k << "] + dYRm[" << i << "][" << m
                  << "] * dYrho[" << s << "] * dYrho[" << k << "] + dYRm[" << i
                  << "][" << k << "] * dYrho[" << m << "] * dYrho[" << s << "]";
            evalg << " + (dYrho[" << k << "] * dYYrho[" << s << "][" << m
                  << "] + dYrho[" << s << "] * dYYrho[" << m << "][" << k
                  << "] + dYrho[" << m << "] * dYYrho[" << s << "][" << k
                  << "]) * Rm[" << i << "]";
            evalg << " ) + Rm[" << i << "] * ( dYGm[" << i << "][" << s
                  << "] * dYrho[" << m << "] * dYrho[" << k << "] + dYGm[" << i
                  << "][" << m << "] * dYrho[" << s << "] * dYrho[" << k
                  << "] + dYGm[" << i << "][" << k << "] * dYrho[" << m
                  << "] * dYrho[" << s << "] ))";
            evalg << " + (" << nubar2prime << ") * (" << nubar2prime - 1
                  << ") * (" << nubar2prime - 2 << ") * pow(rho,"
                  << nubar2prime - 3 << ") * dYrho[" << s << "] * dYrho[" << m
                  << "] * dYrho[" << k << "] * Gm[" << i << "] * Rm[" << i
                  << "]))";
            evalg << ";" << endl;
          }
        }
        evalg << endl;
      }
      evalg << endl;
    }

    // generating dYYTqtilde
    evalg << endl << "   // Generate dYYTqtilde" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nubarprime = 0;
      int nubar2prime = 0;
      for (int s = 0; s < nspec; ++s) {
        nubarprime += nuprime[s][i];
        nubar2prime += nu2prime[s][i];
      }

      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYTqtilde[" << i << "][" << s << "][" << m
                << "] = (dTkf[" << i << "] - (" << nubarprime << ")/T * kf["
                << i << "]) * ( pow(rho," << nubarprime << ") * ( dYYGp[" << i
                << "][" << s << "][" << m << "] * Rp[" << i << "] + dYGp[" << i
                << "][" << s << "] * dYRp[" << i << "][" << m << "] + dYGp["
                << i << "][" << m << "] * dYRp[" << i << "][" << s << "] + Gp["
                << i << "] * dYYRp[" << i << "][" << s << "][" << m << "])";
          evalg << " + (" << nubarprime << ") * pow(rho," << nubarprime - 1
                << ") * ( Rp[" << i << "] * ( Gp[" << i << "] * dYYrho[" << s
                << "][" << m << "] + dYGp[" << i << "][" << s << "] * dYrho["
                << m << "] + dYGp[" << i << "][" << m << "] * dYrho[" << s
                << "]) + Gp[" << i << "] * (dYrho[" << s << "] * dYRp[" << i
                << "][" << m << "] + dYrho[" << m << "] * dYRp[" << i << "]["
                << s << "]) )";
          evalg << " + (" << nubarprime << ") * (" << nubarprime - 1
                << ") * pow(rho," << nubarprime - 2 << ") * dYrho[" << m
                << "] * dYrho[" << s << "] * Gp[" << i << "] * Rp[" << i
                << "])";
          evalg << " - (dTkr[" << i << "] - (" << nubar2prime << ")/T * kr["
                << i << "]) * ( pow(rho," << nubar2prime << ") * ( dYYGm[" << i
                << "][" << s << "][" << m << "] * Rm[" << i << "] + dYGm[" << i
                << "][" << s << "] * dYRm[" << i << "][" << m << "] + dYGm["
                << i << "][" << m << "] * dYRm[" << i << "][" << s << "] + Gm["
                << i << "] * dYYRm[" << i << "][" << s << "][" << m << "])";
          evalg << " + (" << nubar2prime << ") * pow(rho," << nubar2prime - 1
                << ") * ( Rm[" << i << "] * ( Gm[" << i << "] * dYYrho[" << s
                << "][" << m << "] + dYGm[" << i << "][" << s << "] * dYrho["
                << m << "] + dYGm[" << i << "][" << m << "] * dYrho[" << s
                << "]) + Gm[" << i << "] * (dYrho[" << s << "] * dYRm[" << i
                << "][" << m << "] + dYrho[" << m << "] * dYRm[" << i << "]["
                << s << "]) )";
          evalg << " + (" << nubar2prime << ") * (" << nubar2prime - 1
                << ") * pow(rho," << nubar2prime - 2 << ") * dYrho[" << m
                << "] * dYrho[" << s << "] * Gm[" << i << "] * Rm[" << i
                << "]);";
        }
        evalg << endl;
      }
      evalg << endl;
    }

    // generating dYTTqtilde
    evalg << endl << "   // Generate dYYTqtilde" << endl;
    for (int i = 0; i < nreac; ++i) {
      int nubarprime = 0;
      int nubar2prime = 0;
      for (int s = 0; s < nspec; ++s) {
        nubarprime += nuprime[s][i];
        nubar2prime += nu2prime[s][i];
      }

      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTTqtilde[" << i << "][" << s << "] = (dTTkf[" << i
              << "] - 2*(" << nubarprime << ")/T * dTkf[" << i << "] + (("
              << nubarprime << ")+(" << nubarprime << ")*(" << nubarprime
              << "))/(T*T) * kf[" << i << "]) * ( pow(rho," << nubarprime
              << ") * ( dYGp[" << i << "][" << s << "] * Rp[" << i << "] + Gp["
              << i << "] * dYRp[" << i << "][" << s << "]) + (" << nubarprime
              << ") * pow(rho," << nubarprime - 1 << ") * dYrho[" << s
              << "] * Gp[" << i << "] * Rp[" << i << "] )";
        evalg << " - (dTTkr[" << i << "] - 2*(" << nubar2prime << ")/T * dTkr["
              << i << "] + ((" << nubar2prime << ")+(" << nubar2prime << ")*("
              << nubar2prime << "))/(T*T) * kr[" << i << "]) * ( pow(rho,"
              << nubar2prime << ") * ( dYGm[" << i << "][" << s << "] * Rm["
              << i << "] + Gm[" << i << "] * dYRm[" << i << "][" << s
              << "]) + (" << nubar2prime << ") * pow(rho," << nubar2prime - 1
              << ") * dYrho[" << s << "] * Gm[" << i << "] * Rm[" << i
              << "] );";
        evalg << endl;
      }
      evalg << endl;
    }

    // generating dYYYq
    evalg << endl << "   // Generate dYYYq" << endl;
    for (int i = 0; i < nreac; ++i) {
      int ind = thirdBodyOccurs(bodyPos, i);

      // if there isn't a thrid body
      if (ind == -1) {
        for (int s = 0; s < nop; ++s) {
          for (int m = 0; m < nop; ++m) {
            for (int k = 0; k < nop; ++k) {
              evalg << "   dYYYq[" << i << "][" << s << "][" << m << "][" << k
                    << "] = dYYYqtilde[" << i << "][" << s << "][" << m << "]["
                    << k << "];" << endl;
            }
          }
        }
        // otherwise use product rule
      } else {
        int whichThirdBody = bodyNumber[ind] - 1;
        for (int s = 0; s < nop; ++s) {
          for (int m = 0; m < nop; ++m) {
            for (int k = 0; k < nop; ++k) {
              evalg << "   dYYYq[" << i << "][" << s << "][" << m << "][" << k
                    << "] = M[" << whichThirdBody << "] * dYYYqtilde[" << i
                    << "][" << s << "][" << m << "][" << k << "] + dYM["
                    << whichThirdBody << "][" << k << "] * dYYqtilde[" << i
                    << "][" << s << "][" << m << "] + dYM[" << whichThirdBody
                    << "][" << m << "] * dYYqtilde[" << i << "][" << s << "]["
                    << k << "] + dYM[" << whichThirdBody << "][" << s
                    << "] * dYYqtilde[" << i << "][" << m << "][" << k
                    << "] + dYYM[" << whichThirdBody << "][" << s << "][" << m
                    << "] * dYqtilde[" << i << "][" << k << "] + dYYM["
                    << whichThirdBody << "][" << s << "][" << k
                    << "] * dYqtilde[" << i << "][" << m << "] + dYYM["
                    << whichThirdBody << "][" << m << "][" << k
                    << "] * dYqtilde[" << i << "][" << s << "] + dYYYM["
                    << whichThirdBody << "][" << s << "][" << m << "][" << k
                    << "] * qtilde[" << i << "];" << endl;
            }
          }
        }
      }
      evalg << endl;
    }

    // generating dYYTq
    evalg << endl << "   // Generate dYYTq" << endl;
    for (int i = 0; i < nreac; ++i) {
      int ind = thirdBodyOccurs(bodyPos, i);

      // if there isn't a thrid body
      if (ind == -1) {
        for (int s = 0; s < nop; ++s) {
          for (int m = 0; m < nop; ++m) {
            evalg << "   dYYTq[" << i << "][" << s << "][" << m
                  << "] = dYYTqtilde[" << i << "][" << s << "][" << m << "];"
                  << endl;
          }
        }
        // otherwise use product rule
      } else {
        int whichThirdBody = bodyNumber[ind] - 1;
        for (int s = 0; s < nop; ++s) {
          for (int m = 0; m < nop; ++m) {
            evalg << "   dYYTq[" << i << "][" << s << "][" << m << "] = M["
                  << whichThirdBody << "] * dYYTqtilde[" << i << "][" << s
                  << "][" << m << "] + dTM[" << whichThirdBody
                  << "] * dYYqtilde[" << i << "][" << s << "][" << m
                  << "] + dYM[" << whichThirdBody << "][" << m
                  << "] * dYTqtilde[" << i << "][" << s << "] + dYM["
                  << whichThirdBody << "][" << s << "] * dYTqtilde[" << i
                  << "][" << m << "] + dYYM[" << whichThirdBody << "][" << s
                  << "][" << m << "] * dTqtilde[" << i << "] + dYTM["
                  << whichThirdBody << "][" << s << "] * dYqtilde[" << i << "]["
                  << m << "] + dYTM[" << whichThirdBody << "][" << m
                  << "] * dYqtilde[" << i << "][" << s << "] + dYYTM["
                  << whichThirdBody << "][" << s << "][" << m << "] * qtilde["
                  << i << "];" << endl;
          }
        }
      }
      evalg << endl;
    }

    // generating dYTTq
    evalg << endl << "   // Generate dYTTq" << endl;
    for (int i = 0; i < nreac; ++i) {
      int ind = thirdBodyOccurs(bodyPos, i);

      // if there isn't a thrid body
      if (ind == -1) {
        for (int s = 0; s < nop; ++s) {
          evalg << "   dYTTq[" << i << "][" << s << "] = dYTTqtilde[" << i
                << "][" << s << "];" << endl;
        }
        // otherwise use product rule
      } else {
        int whichThirdBody = bodyNumber[ind] - 1;
        for (int s = 0; s < nop; ++s) {
          evalg << "   dYTTq[" << i << "][" << s << "] = M[" << whichThirdBody
                << "] * dYTTqtilde[" << i << "][" << s << "] + 2 * dTM["
                << whichThirdBody << "] * dYTqtilde[" << i << "][" << s
                << "] + dYM[" << whichThirdBody << "][" << s << "] * dTTqtilde["
                << i << "] + 2 * dYTM[" << whichThirdBody << "][" << s
                << "] * dTqtilde[" << i << "] + dTTM[" << whichThirdBody
                << "] * dYqtilde[" << i << "][" << s << "] + dYTTM["
                << whichThirdBody << "][" << s << "] * qtilde[" << i << "];"
                << endl;
        }
      }
      evalg << endl;
    }

    // generating dYYYomega
    evalg << endl << "   // Generate dYYYomega" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYomega[" << i << "][" << s << "][" << m << "][" << k
                  << "] = 0.0";
            for (int r = 0; r < nreac; ++r) {
              if (nu[Iop[i] - 1][r] != 0)
                evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYYYq[" << r
                      << "][" << s << "][" << m << "][" << k << "]";
            }
            evalg << ";" << endl;
          }
        }
        evalg << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYYTomega
    evalg << endl << "   // Generate dYYTomega" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYTomega[" << i << "][" << s << "][" << m << "] = 0.0";
          for (int r = 0; r < nreac; ++r) {
            if (nu[Iop[i] - 1][r] != 0)
              evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYYTq[" << r << "]["
                    << s << "][" << m << "]";
          }
          evalg << ";" << endl;
        }
        evalg << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYTTomega
    evalg << endl << "   // Generate dYTTomega" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTTomega[" << i << "][" << s << "] = 0.0";
        for (int r = 0; r < nreac; ++r) {
          if (nu[Iop[i] - 1][r] != 0)
            evalg << " + (" << nu[Iop[i] - 1][r] << ") * dYTTq[" << r << "]["
                  << s << "]";
        }
        evalg << ";" << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYYYf
    evalg << endl << "   // Generate dYYYf" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          for (int k = 0; k < nop; ++k) {
            evalg << "   dYYYf[" << i << "][" << s << "][" << m << "][" << k
                  << "] = Ms[" << Iop[i] - 1 << "] * ( 1/rho * dYYYomega[" << i
                  << "][" << s << "][" << m << "][" << k << "]";
            evalg << " - 1/(rho*rho) * (dYYrho[" << m << "][" << k
                  << "] * dYomega[" << i << "][" << s << "] + dYYrho[" << s
                  << "][" << k << "] * dYomega[" << i << "][" << m
                  << "] + dYYrho[" << s << "][" << m << "] * dYomega[" << i
                  << "][" << k << "] + dYrho[" << k << "] * dYYomega[" << i
                  << "][" << s << "][" << m << "] + dYrho[" << m
                  << "] * dYYomega[" << i << "][" << s << "][" << k
                  << "] + dYrho[" << s << "] * dYYomega[" << i << "][" << m
                  << "][" << k << "] + omega[" << i << "] * dYYYrho[" << s
                  << "][" << m << "][" << k << "])";
            evalg << " + 2/(rho*rho*rho) * ( omega[" << i << "] * ( dYrho[" << k
                  << "] * dYYrho[" << s << "][" << m << "] + dYrho[" << m
                  << "] * dYYrho[" << s << "][" << k << "] + dYrho[" << s
                  << "] * dYYrho[" << m << "][" << k << "]) + dYrho[" << k
                  << "] * dYrho[" << m << "] * dYomega[" << i << "][" << s
                  << "] + dYrho[" << k << "] * dYrho[" << s << "] * dYomega["
                  << i << "][" << m << "] + dYrho[" << s << "] * dYrho[" << m
                  << "] * dYomega[" << i << "][" << k << "])";
            evalg << " - 6/(rho*rho*rho*rho) * dYrho[" << k << "] * dYrho[" << s
                  << "] * dYrho[" << m << "] * omega[" << i << "]);" << endl;
          }
        }
        evalg << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYYTf
    evalg << endl << "   // Generate dYYTf" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        for (int m = 0; m < nop; ++m) {
          evalg << "   dYYTf[" << i << "][" << s << "][" << m << "] = Ms["
                << Iop[i] - 1 << "] * ( 1/rho * (dYYTomega[" << i << "][" << s
                << "][" << m << "] + 1/T * dYYomega[" << i << "][" << s << "]["
                << m << "])";
          evalg << " - 1/(rho*rho) * (dYrho[" << m << "] * dYTomega[" << i
                << "][" << s << "] + dYYrho[" << s << "][" << m
                << "] * dTomega[" << i << "] + dYrho[" << s << "] * dYTomega["
                << i << "][" << m << "] + 1/T * dYrho[" << m << "] * dYomega["
                << i << "][" << s << "] + 1/T * dYYrho[" << s << "][" << m
                << "] * omega[" << i << "] + 1/T * dYrho[" << s
                << "] * dYomega[" << i << "][" << m << "])";
          evalg << " + 2/(rho*rho*rho) *  dYrho[" << s << "] * dYrho[" << m
                << "] * (dTomega[" << i << "] + omega[" << i << "]/T));";
        }
        evalg << endl;
      }
      evalg << endl;
    }
    evalg << endl;

    // generating dYTTf
    evalg << endl << "   // Generate dYTTf" << endl;
    for (int i = 0; i < nop; ++i) {
      for (int s = 0; s < nop; ++s) {
        evalg << "   dYTTf[" << i << "][" << s << "] = Ms[" << Iop[i] - 1
              << "] * ( 1/rho * (dYTTomega[" << i << "][" << s
              << "] + 2/T * dYTomega[" << i << "][" << s << "])";
        evalg << " - 1/(rho*rho) *  dYrho[" << s << "] * (dTTomega[" << i
              << "] + 2*dTomega[" << i << "]/T));";
      }
      evalg << endl;
    }
    evalg << endl;
  }

  // close function
  evalg << endl << "}" << endl << endl;

  evalg.close();
}

void generateMatlabTools(vector<string> species, vector<double> Ms,
                         vector<double> Ma, vector<vector<double>> consMatrix,
                         vector<vector<double>> nasa,
                         vector<double> switchingPoints) {

  // get nspec and time for time stamp
  int nspec = species.size();
  int natom = consMatrix.size();
  int nop = NOP;
  int nnop = NNOP;
  int Iop[NOP] = IOP;
  int Inop[NNOP] = INOP;

  time_t t;
  time(&t);

  ofstream out("calculateEnthalpy.m");
  out << "% Autogenerated file on " << ctime(&t);
  out << "% calculateEnthalpy.m" << endl;
  out << "%    Description: Calculates the specific enthalpy of X = (Y,T)"
      << endl;
  out << "%    Input: X = (Y,T) whereas Y are mass fractions of species, T "
         "temperature."
      << endl;
  out << "%    Output: h = caluclated specific enthalpy." << endl;
  out << "function h = calculateEnthalpy(X)" << endl << endl;
  out << "%set variables" << endl;
  out << "Y = X(1:end-1);" << endl;
  out << "T = X(end);" << endl;
  out << "Tvec = [T, T^2/2.0, T^3/3.0, T^4/4.0, T^5/5.0, 1 ,0 ];" << endl;
  out << "R = 8.3144598;" << endl;
  out << "gamma  = 20; % transition parameter" << endl;
  out << endl;

  out << "Ms = [";
  for (int i = 0; i < Ms.size(); ++i) {
    out << std::setprecision(15) << 1e-3 * Ms[i] << " ";
  }
  out << "]; \% molar weights in kg/mol" << endl;

  // generating nasa
  out << "nasa = [";
  for (int i = 0; i < nspec; ++i) {
    for (int k = 0; k < 14; ++k) {
      out << nasa[i][k] << " ";
    }
    out << ";" << endl;
  }
  out << "]; % coefficients for nasa polynomials - each line: "
         "[a1_low,...,a7_low,a1_high,..,a7_high]"
      << endl;

  // generating switching points
  out << "T_sw = [";
  for (int k = 0; k < nspec; ++k) {
    out << switchingPoints[k] << " ";
  }
  out << "];" << endl;

  out << endl;

  // calculate Hlow, Hhigh
  out << "for s = 1:" << nspec << endl;
  out << "   Hlow(s) = R*sum(nasa(s,1:7) .* Tvec);" << endl;
  out << "   Hhigh(s) = R*sum(nasa(s,8:end) .* Tvec);" << endl;
  out << "   sigma = 1/2*tanh(gamma*(T-T_sw(s))) + 1/2;" << endl;
  out << "   H(s) = (1-sigma)*Hlow(s) + sigma*Hhigh(s);" << endl;
  out << "end" << endl << endl;

  // set enthalpy
  out << "h = H*(Y./Ms)';" << endl;

  // close file
  out.close();

  out.open("getResolution.m");
  out << "% Autogenerated file on " << ctime(&t);
  out << "% getResolution.m" << endl;
  out << "%    Description: Resolve the mass constraints and returns function "
         "handles"
      << endl;
  out << "%                 to represent Inop species." << endl;
  out << "%    Input: ammsock object." << endl;
  out << "%    Output: cell array including resolutions of Inop species."
      << endl;
  out << "function Yres_func = getResolution(ammsock)" << endl << endl;
  out << "% get data" << endl;
  out << "Inop = ammsock.Inop;" << endl;
  out << "Iop = ammsock.Iop;" << endl;
  out << "atomFixed = ammsock.atomCons;" << endl << endl;
  out << "% check if there should be a resolution" << endl;
  out << "if (isempty(Inop))" << endl;
  out << "   Yres_func = [];" << endl;
  out << "else" << endl;
  out << "% define conservation matrix" << endl;
  out << "consMatrix = [";
  for (int a = 0; a < natom; ++a) {
    for (int s = 0; s < nspec; ++s) {
      out << setprecision(20) << consMatrix[a][s] << " ";
    }
    if (a < (natom - 1)) {
      out << ";" << endl;
    }
  }
  out << "];" << endl << endl;

  out << "% check if resolution is posssible by checking rank" << endl;
  out << "if rank(consMatrix(:,Inop)) ~= size(consMatrix,1) " << endl;
  out << "   error('Resolution is not possible. Please choose other species.')"
      << endl;
  out << "end" << endl << endl;

  out << "% define symbolic variables" << endl;
  out << "syms ";
  for (int s = 0; s < nspec; ++s) {
    out << "Y" << s + 1 << " ";
  }
  for (int a = 0; a < natom; ++a) {
    out << "consAtom" << a + 1 << " ";
  }
  out << ";" << endl;
  out << "Y = [";
  for (int s = 0; s < nspec; ++s) {
    out << "Y" << s + 1 << "; ";
  }
  out << "];" << endl << endl;
  out << "rhs = [";
  for (int a = 0; a < natom; ++a) {
    out << "consAtom" << a + 1 << "; ";
  }
  out << "];" << endl << endl;

  out << "% solve linear equation system" << endl;
  out << "sol = solve(consMatrix*Y==rhs,Y(Inop));" << endl;
  out << endl;

  out << "% differentiate each solution" << endl;
  out << "diffstring = cell(1,length(Inop));" << endl;
  out << "for i=1:length(Inop)" << endl;
  out << "   diffstring{i} = '';" << endl;
  out << "    for j=1:length(Iop)" << endl;
  out << "        diffstring{i} = [diffstring{i},', "
         "(double)',char(vpa(diff(getfield(sol,sprintf('Y%i',Inop(i))),Y(Iop(j)"
         ")),40))];"
      << endl;
  out << "    end" << endl;
  out << "    diffstring{i}(1) = [];" << endl;
  out << "end" << endl << endl;

  out << "% get string of solutions" << endl;
  out << "sol_string = cell(1,length(Inop));" << endl;
  out << "for i=1:length(Inop)" << endl;
  out << "   sol_string{i} = "
         "char(vpa(getfield(sol,sprintf('Y%i',Inop(i))),40));"
      << endl;
  out << "end" << endl << endl;

  out << "% replace substrings to parse either to matlab funcion handles or c++"
      << endl;
  out << "Yres_func = cell(1,length(Inop));" << endl;
  out << "func_string = sol_string;" << endl;
  out << "for j=1:length(Inop)" << endl;
  out << "    for i=length(Iop):-1:1	" << endl;
  out << "        func_string{j} = "
         "strrep(func_string{j},sprintf('Y%i',Iop(i)),sprintf('Y(%i)',i));"
      << endl;
  out << "        sol_string{j}= "
         "strrep(sol_string{j},sprintf('Y%i',Iop(i)),sprintf('_Y[%i]',i-1));"
      << endl;
  out << "    end" << endl;
  out << "    for k=1:length(Inop)" << endl;
  out << "       func_string{j} = "
         "strrep(func_string{j},sprintf('consAtom%i',k),sprintf('%1.25f',"
         "atomFixed(k)));"
      << endl;
  out << "       sol_string{j} = "
         "strrep(sol_string{j},sprintf('consAtom%i',k),sprintf('consAtom[%i]',"
         "k-1));"
      << endl;
  out << "    end" << endl;
  out << "    func_string{j} = ['@(Y)',func_string{j}];" << endl;
  out << "    Yres_func{j} = str2func(func_string{j});" << endl;
  out << "end" << endl << endl;
  out << "end %else" << endl << endl;

  out << "% write resolution to *.hpp file" << endl;
  out << "fid = fopen([ammsock.workingDir,'/cpp/resolution.hpp'], 'w');"
      << endl;
  out << "for i=1:length(Inop)" << endl;
  out << "    fprintf(fid, '#define Y%iRES %s\\n', Inop(i)-1, sol_string{i});"
      << endl;
  out << "end" << endl;
  out << "for i=1:length(Inop)" << endl;
  out << "    fprintf(fid, '#define DIFFY%iRES {%s}\\n', Inop(i)-1, "
         "diffstring{i});"
      << endl;
  out << "end" << endl;
  out << "fclose(fid);" << endl;

  // close file
  out.close();

  out.open("getFullState.m");
  out << "% Autogenerated file on " << ctime(&t);
  out << "% getFullState.m" << endl;
  out << "%    Description: Reconstruct the full state vector according"
      << endl;
  out << "%                 to the resolutions of mass constraints." << endl;
  out << "%    Input: reduced state vectors V in IR^(nx times nspec+1)" << endl;
  out << "%           ammsock object" << endl;
  out << "%    Output: Full state vectors F." << endl;
  out << "function F = getFullState(V,ammsock)" << endl << endl;
  out << "% get data" << endl;
  out << "Yres = ammsock.Yres;" << endl;
  out << "nspec = ammsock.nspec;" << endl << endl;
  out << "%allocate memory" << endl;
  out << "nx = size(V,1);" << endl;
  out << "F = zeros(nx,nspec+1);" << endl << endl;

  out << "for i = 1:nx" << endl;
  out << "   %set Iop states" << endl;
  for (int i = 0; i < nop; ++i) {
    out << "   F(i," << Iop[i] << ") = V(i," << i + 1 << ");" << endl;
  }
  out << "   %set Inop states" << endl;
  for (int i = 0; i < nnop; ++i) {
    out << "   F(i," << Inop[i] << ") = Yres{" << i + 1 << "}(V(i,:));" << endl;
  }
  out << "   %set temperature" << endl;
  out << "   F(i," << nspec + 1 << ") = V(i,end);" << endl;
  out << "end" << endl;
  out.close();

  out.open("getFixedAtomValues.m");
  out << "% Autogenerated file on " << ctime(&t);
  out << "% getFixedAtomValues.m" << endl;
  out << "%    Description: Calculate the conservation constants of each atom"
      << endl;
  out << "%    Input: mixture fraction Z in [0,1]" << endl;
  out << "%    Output: vector containing conservation constants according"
      << endl;
  out << "%            to order in ammsock.atoms." << endl;
  out << "function cA = getFixedAtomValues(Z)" << endl << endl;
  out << "% define conservation matrix" << endl;
  out << "consMatrix = [";
  for (int a = 0; a < natom; ++a) {
    for (int s = 0; s < nspec; ++s) {
      out << setprecision(20) << consMatrix[a][s] << " ";
    }
    if (a < (natom - 1)) {
      out << ";" << endl;
    }
  }
  out << "];" << endl << endl;

  out << "% use getInitialValue and consMatrix to calculate cA" << endl;
  out << "Yinit = getInitialValue(Z,-42);" << endl;
  out << "Yinit(end) = [];" << endl;
  out << "cA = consMatrix*Yinit';" << endl;

  out << "end" << endl;
  out.close();

  out.open("getInitialValue.m");
  out << "% Autogenerated file on " << ctime(&t);
  out << "% getInitialValue.m" << endl;
  out << "%    Description: Calculate an initial value according to mixture "
         "fraction"
      << endl;
  out << "%    Input: mixture fraction Z in [0,1]" << endl;
  out << "%    Output: initial value" << endl;
  out << "function Yinit = getInitialValue(Z,T)" << endl << endl;

  string fuel = FUEL;
  string oxidizer = OXIDIZER;
  int index, index2, index3;
  index = getIndexOfToken(fuel, species);
  out << "% set indicies for fuel and oxidizer" << endl;
  out << "index_fuel = " << index + 1 << ";" << endl;
  out << "m_fuel = " << setprecision(15) << 1e-3 * Ms[index] << ";"
      << endl; // convert to kg

  if (oxidizer.compare("O2") == 0) {
    index = getIndexOfToken("O2", species);
    out << "index_oxidizer = " << index + 1 << ";" << endl;
    out << "ratio_oxidizer = 1;" << endl;
    out << "m_oxidizer = " << 1e-3 * Ms[index] << ";" << endl; // convert to kg
  } else if (oxidizer.compare("Air(N2,O2)") == 0) {
    index = getIndexOfToken("O2", species);
    index2 = getIndexOfToken("N2", species);
    out << "index_oxidizer = [" << index + 1 << ", " << index2 + 1 << "];"
        << endl;
    out << "ratio_oxidizer = [0.21 0.79];" << endl;
    out << "m_oxidizer = [" << 1e-3 * Ms[index] << ", " << 1e-3 * Ms[index2]
        << "];" << endl; // convert to kg
  } else if (oxidizer.compare("Air(N2,O2,Ar)") == 0) {
    index = getIndexOfToken("O2", species);
    index2 = getIndexOfToken("N2", species);
    index3 = getIndexOfToken("Ar", species);
    out << "index_oxidizer = [" << index + 1 << ", " << index2 + 1 << ", "
        << index3 + 1 << "];" << endl;
    out << "ratio_oxidizer = [0.21 0.781 0.009];" << endl;
    out << "m_oxidizer = [" << 1e-3 * Ms[index] << ", " << 1e-3 * Ms[index2]
        << ", " << 1e-3 * Ms[index3] << "];" << endl; // convert to kg
  }
  out << endl;

  out << "% caluclate total mass fraction" << endl;
  out << "m_all = Z*m_fuel + (1-Z)*sum(m_oxidizer.*ratio_oxidizer);" << endl
      << endl;

  out << "% set initial value" << endl;
  out << "Yinit = zeros(1," << nspec + 1 << ");" << endl;
  out << "Yinit(index_fuel) = Z*m_fuel/m_all;" << endl;
  out << "for i = 1:length(index_oxidizer)" << endl;
  out << "   Yinit(index_oxidizer(i)) = "
         "(1-Z)*ratio_oxidizer(i)*m_oxidizer(i)/m_all;"
      << endl;
  out << "end" << endl;
  out << "Yinit(end) = T;" << endl << endl;

  out << "end" << endl;

  out.close();

  out.open("computeManifold.m");
  out << "% Autogenerated file on " << ctime(&t);
  out << "% computeManifold.m" << endl;
  out << "%    Description: Calculate the slow invariant manifold points."
      << endl;
  out << "%    Input: grid_rpv - cell array with discretizations of each "
         "reaction"
      << endl;
  out << "%                      progress variable." << endl;
  out << "%           init - inital guess." << endl;
  out << "%           ammsock - ammsock object." << endl;
  out << "%    Output: SIM - a min(nSim, successfulReduction) times nspec+1 "
         "matrix"
      << endl;
  out << "%                  containing the successfully computed SIM points."
      << endl;
  out << "%            it - required iterations for each SIM point." << endl;
  out << "function [SIM,it] = computeManifold(grid_rpv,initalvalue,ammsock)"
      << endl
      << endl;

  out << "% check if grid_rpv has valid dimension" << endl;
  out << "if size(grid_rpv,2) ~= ammsock.nrpv" << endl;
  out << "   error('computeManifold: grid_rpv must be a cell array with "
         "dimension (1 x nrpv).');"
      << endl;
  out << "end" << endl << endl;

  out << "% setting parameters" << endl;
  out << "param.hfixed = ammsock.hfixed;" << endl;
  out << "param.atomCons = ammsock.atomCons;" << endl;
  out << "param.maxit = ammsock.maxit;" << endl;
  out << "param.hcoll = ammsock.hcoll;" << endl;
  out << "param.scale = ammsock.scale;" << endl;
  out << "nrpv = ammsock.nrpv;" << endl << endl;
  out << "indexRpv = zeros(1,nrpv);" << endl;
  out << "for i=1:nrpv" << endl;
  out << "   indexRpv(i) = find(ammsock.Iop==ammsock.indexRpv(i));" << endl;
  out << "end" << endl;
  out << "if (strcmp(ammsock.exactHessian,'true'))" << endl;
  out << "   param.exactHessian = 1;" << endl;
  out << "elseif (strcmp(ammsock.exactHessian,'false'))" << endl;
  out << "   param.exactHessian = 0;" << endl;
  out << "else" << endl;
  out << "   error('computeManifold: exactHessian must be true or false.');"
      << endl;
  out << "end" << endl;

  out << "% initialize output parameters" << endl;
  out << "SIM = [];" << endl;
  out << "it = [];" << endl;
  out << "init = initalvalue;" << endl << endl;

  out << "% loop over grid" << endl;
  for (int i = 0; i < NRPV; ++i) {
    out << std::string(i * 3, ' ') << "for k" << i + 1 << "=1:length(grid_rpv{"
        << i + 1 << "})" << endl;
  }
  out << std::string(NRPV * 3, ' ') << "p = [";
  for (int i = 0; i < NRPV; ++i) {
    out << "grid_rpv{" << i + 1 << "}(k" << i + 1 << "), ";
  }
  out << "]" << endl;
  out << std::string(NRPV * 3, ' ')
      << "[exit,nit,yfull] = performReduction(p,init,param);" << endl;
  out << std::string(NRPV * 3, ' ') << "if (exit == 0) || (exit == 1)" << endl;
  out << std::string(NRPV * 3 + 3, ' ') << "SIM = [SIM;yfull];" << endl;
  out << std::string(NRPV * 3 + 3, ' ') << "init = yfull;" << endl;
  out << std::string(NRPV * 3, ' ') << "end" << endl;
  out << std::string(NRPV * 3, ' ') << "it = [it,nit]" << endl;
  for (int i = 0; i < NRPV; ++i) {
    out << std::string((NRPV - 1 - i) * 3, ' ') << "end" << endl;
    if (i < NRPV - 1) {
      out << std::string((NRPV - 1 - i) * 3, ' ')
          << "% get closest previously calculated SIM point" << endl;
      out << std::string((NRPV - 1 - i) * 3, ' ') << "nSim = size(SIM,1);"
          << endl;
      out << std::string((NRPV - 1 - i) * 3, ' ') << "if nSim > 0" << endl;
      out << std::string((NRPV - 1 - i) * 3 + 3, ' ')
          << "[val,ind] =  min(sum((SIM(:,indexRpv)-ones(nSim,nrpv)*diag([";
      for (int k = 0; k < NRPV - i - 1; ++k) {
        out << "grid_rpv{" << k + 1 << "}(k" << k + 1 << ") ";
      }
      for (int k = NRPV - i - 1; k < NRPV; ++k) {
        out << "grid_rpv{" << k + 1 << "}(1) ";
      }
      out << "])).^2,2));" << endl;
      out << std::string((NRPV - 1 - i) * 3 + 3, ' ') << "init = SIM(ind,:);"
          << endl;
      out << std::string((NRPV - 1 - i) * 3, ' ') << "end" << endl;
    }
  }
  out << endl;

  out << "end" << endl;
  out.close();
}

int main(int argc, char *argv[]) {

  // check arguments
  assert(argc == 4);

  // perliminaries
  int nreac = 0, nspec = 0, natom = 0, ntb = 0, nrtb = 0, nfr = 0;

  string line;

  // create streams
  string path = argv[1];
  string filename = argv[2];
  string convertTo = argv[3];

  // read mech data
  ifstream mechdata((path + "/data/mechdata.dat").c_str(), ios_base::in);

  // read species and their molar weights
  getline(mechdata, line);
  istringstream iss(line);
  iss >> nspec;
  vector<string> species(nspec);
  vector<double> Ms(nspec, 0.0);
  for (int s = 0; s < nspec; ++s) {
    getline(mechdata, line);
    istringstream iss(line);
    iss >> species[s];
    iss >> Ms[s];
  }

  // read atoms and their molar weights
  getline(mechdata, line);
  istringstream iss_natom(line);
  iss_natom >> natom;
  vector<string> atoms(natom);
  vector<double> Ma(natom, 0.0);
  for (int a = 0; a < natom; ++a) {
    getline(mechdata, line);
    istringstream iss(line);
    iss >> atoms[a];
    iss >> Ma[a];
  }

  // read nreac, nuprime, nu2prime
  getline(mechdata, line);
  istringstream iss_nreac(line);
  iss_nreac >> nreac;
  vector<vector<int>> nuprime;
  vector<vector<int>> nu2prime;
  for (int s = 0; s < nspec; ++s) {
    nuprime.push_back(vector<int>(nreac, 0));
    getline(mechdata, line);
    istringstream iss(line);
    for (int r = 0; r < nreac; ++r) {
      iss >> nuprime[s][r];
    }
  }
  for (int s = 0; s < nspec; ++s) {
    nu2prime.push_back(vector<int>(nreac, 0));
    getline(mechdata, line);
    istringstream iss(line);
    for (int r = 0; r < nreac; ++r) {
      iss >> nu2prime[s][r];
    }
  }

  // read third body collision efficiencies
  getline(mechdata, line);
  istringstream iss_ntb(line);
  iss_ntb >> ntb;
  vector<vector<double>> bodyCoeff;
  for (int i = 0; i < ntb; ++i) {
    bodyCoeff.push_back(vector<double>(nspec, 0));
    getline(mechdata, line);
    istringstream iss(line);
    for (int s = 0; s < nspec; ++s) {
      iss >> bodyCoeff[i][s];
    }
  }

  // read third body position and number
  getline(mechdata, line);
  istringstream iss_nrtb(line);
  iss_nrtb >> nrtb;
  vector<int> bodyPos(nrtb, 0);
  vector<int> bodyNumber(nrtb, 0);
  for (int i = 0; i < nrtb; ++i) {
    getline(mechdata, line);
    istringstream iss(line);
    iss >> bodyPos[i];
    iss >> bodyNumber[i];
  }

  // read third body info
  getline(mechdata, line);
  istringstream iss_nfr(line);
  iss_nfr >> nfr;
  vector<int> forwardReactions(nfr, 0);
  for (int i = 0; i < nfr; ++i) {
    getline(mechdata, line);
    istringstream iss(line);
    iss >> forwardReactions[i];
  }

  // read conservation matrix
  vector<vector<double>> consMatrix(natom, vector<double>(nspec, 0.0));
  for (int a = 0; a < natom; ++a) {
    getline(mechdata, line);
    istringstream iss(line);
    for (int s = 0; s < nspec; ++s) {
      iss >> consMatrix[a][s];
    }
  }

  // open thermodata
  ifstream thermodata((path + "/data/thermodata.dat").c_str(), ios_base::in);
  vector<double> A(nreac, 0.0), b(nreac, 0.0), Ea(nreac, 0.0);
  vector<vector<double>> nasa(nspec, vector<double>(14, 0.0));
  vector<double> switchingPoints(nspec, 0.0);

  // read A, b and Ea for each reaction
  for (int r = 0; r < nreac; ++r) {
    getline(thermodata, line);
    istringstream iss(line);
    iss >> A[r];  // A
    iss >> b[r];  // b
    iss >> Ea[r]; // Ea
  }

  // read nasa polynomials coefficients and switching points
  for (int s = 0; s < nspec; ++s) {
    getline(thermodata, line);
    istringstream iss(line);
    for (int k = 0; k < 14; ++k) {
      iss >> nasa[s][k];
    }
    iss >> switchingPoints[s];
  }

  // generating code

  generateRates(A, b, Ea, species, nuprime, nu2prime, Ms, forwardReactions,
                nasa, switchingPoints, convertTo, filename);

  if (convertTo.compare("c++") == 0) {
    generateEvalF(nspec, nreac, species, nuprime, nu2prime, bodyPos, bodyNumber,
                  bodyCoeff, Ms, filename);
    generateEvalGradF(nspec, nreac, species, nuprime, nu2prime, bodyPos,
                      bodyNumber, bodyCoeff, Ms, filename);
    generateEvalG(species, nuprime, nu2prime, consMatrix, Ms, bodyPos,
                  bodyNumber, bodyCoeff, filename);
    generateEvalJacG(species, nuprime, nu2prime, consMatrix, Ms, bodyPos,
                     bodyNumber, bodyCoeff, filename);
    generateEvalH(nspec, nreac, species, nuprime, nu2prime, bodyPos, bodyNumber,
                  bodyCoeff, Ms, filename);
    generateAuxiliary(species, nuprime, nu2prime, consMatrix, Ms, bodyPos,
                      bodyNumber, bodyCoeff, filename);
    generateBoundsInfo(nspec, species, natom, filename);
    generateNLPInfo(nspec, species, natom, filename);
  }

  if (convertTo.compare("matlab") == 0) {
    generateRHS(nspec, nreac, natom, species, nuprime, nu2prime, bodyPos,
                bodyNumber, bodyCoeff, Ms, nasa, switchingPoints, filename);
    generateMatlabTools(species, Ms, Ma, consMatrix, nasa, switchingPoints);
  }

  cout << "\n*** Generator: Work done. " << convertTo << "-Code generated. ***"
       << endl
       << endl;

  return 0;
}
